mdl 1.4;
using shared import *;
import mtlx::utilities::*;
import math::*;
import anno::*;
import base::*;
import tex::*;
import state::*;
import df::*;
import alg::base::core::*;
import alg::base::annotations::*;

export float3 getGeomPropDef_Pobject() [[ anno::hidden() ]]
{
    return state::transform_point(state::coordinate_internal, state::coordinate_object, state::position());
}
export float3 getGeomPropDef_Nobject() [[ anno::hidden() ]]
{
    return state::transform_normal(state::coordinate_internal, state::coordinate_object, state::normal());
}
export float3 getGeomPropDef_Tobject() [[ anno::hidden() ]]
{
    return state::transform_vector(state::coordinate_internal, state::coordinate_object, state::geometry_tangent_u(0));
}
export float3 getGeomPropDef_Pworld() [[ anno::hidden() ]]
{
    return state::transform_point(state::coordinate_internal, state::coordinate_world, state::position());
}
export float3 getGeomPropDef_Nworld() [[ anno::hidden() ]]
{
    return state::transform_normal(state::coordinate_internal, state::coordinate_world, state::normal());
}
export float3 getGeomPropDef_Tworld() [[ anno::hidden() ]]
{
    return state::transform_vector(state::coordinate_internal, state::coordinate_world, state::geometry_tangent_u(0));
}
export float2 getGeomPropDef_UV0() [[ anno::hidden() ]]
{
    return float2(state::texture_coordinate(0).x, state::texture_coordinate(0).y);
}
// Warning: No data map for geometry property viewdirection

export float image_float(
    varying float2 texcoord=getGeomPropDef_UV0(),
    uniform texture_2d file=texture_2d()[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string layer=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float default_=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string uaddressmode=string("periodic")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string vaddressmode=string("periodic")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string filtertype=string("linear")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string framerange=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform int frameoffset=int(0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string frameendaction=string("black")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string attr_GLSLFX_usage=""[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx image"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    if(tex::texture_isvalid(file)) {
        return tex::lookup_float(
            file, texcoord, mtlx::utilities::get_wrap_mode(uaddressmode),mtlx::utilities::get_wrap_mode(vaddressmode));
    } else {
        return default_;
    }
}
// Unsupported MaterialX nodedef ND_image_color2 skipped
export color3 image_color3(
    varying float2 texcoord=getGeomPropDef_UV0(),
    uniform texture_2d file=texture_2d()[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string layer=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform color3 default_=color3(0.0, 0.0, 0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string uaddressmode=string("periodic")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string vaddressmode=string("periodic")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string filtertype=string("linear")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string framerange=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform int frameoffset=int(0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string frameendaction=string("black")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string attr_GLSLFX_usage=""[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx image"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    if(tex::texture_isvalid(file)) {
        return tex::lookup_color(
            file, texcoord, mtlx::utilities::get_wrap_mode(uaddressmode),mtlx::utilities::get_wrap_mode(vaddressmode));
    } else {
        return default_;
    }
}
// Unsupported MaterialX nodedef ND_image_color4 skipped
export float2 image_vector2(
    varying float2 texcoord=getGeomPropDef_UV0(),
    uniform texture_2d file=texture_2d()[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string layer=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float2 default_=float2(0.0, 0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string uaddressmode=string("periodic")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string vaddressmode=string("periodic")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string filtertype=string("linear")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string framerange=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform int frameoffset=int(0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string frameendaction=string("black")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string attr_GLSLFX_usage=""[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx image"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    if(tex::texture_isvalid(file)) {
        return tex::lookup_float2(
            file, texcoord, mtlx::utilities::get_wrap_mode(uaddressmode),mtlx::utilities::get_wrap_mode(vaddressmode));
    } else {
        return default_;
    }
}
export float3 image_vector3(
    varying float2 texcoord=getGeomPropDef_UV0(),
    uniform texture_2d file=texture_2d()[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string layer=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float3 default_=float3(0.0, 0.0, 0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string uaddressmode=string("periodic")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string vaddressmode=string("periodic")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string filtertype=string("linear")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string framerange=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform int frameoffset=int(0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string frameendaction=string("black")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string attr_GLSLFX_usage=""[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx image"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    if(tex::texture_isvalid(file)) {
        return tex::lookup_float3(
            file, texcoord, mtlx::utilities::get_wrap_mode(uaddressmode),mtlx::utilities::get_wrap_mode(vaddressmode));
    } else {
        return default_;
    }
}
export float4 image_vector4(
    varying float2 texcoord=getGeomPropDef_UV0(),
    uniform texture_2d file=texture_2d()[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string layer=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float4 default_=float4(0.0, 0.0, 0.0, 0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string uaddressmode=string("periodic")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string vaddressmode=string("periodic")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string filtertype=string("linear")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string framerange=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform int frameoffset=int(0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string frameendaction=string("black")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string attr_GLSLFX_usage=""[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx image"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    if(tex::texture_isvalid(file)) {
        return tex::lookup_float4(
            file, texcoord, mtlx::utilities::get_wrap_mode(uaddressmode),mtlx::utilities::get_wrap_mode(vaddressmode));
    } else {
        return default_;
    }
}
export float tiledimage_float(
    varying float2 texcoord=getGeomPropDef_UV0(),
    uniform texture_2d file=texture_2d()[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float default_=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float2 uvtiling=float2(1.0, 1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float2 uvoffset=float2(0.0, 0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string filtertype=string("linear")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string framerange=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform int frameoffset=int(0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string frameendaction=string("black")[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx tiledimage"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    if(tex::texture_isvalid(file)) {
        return tex::lookup_float(
            file, (texcoord/uvtiling)-uvoffset);
    } else {
        return default_;
    }
}
// Unsupported MaterialX nodedef ND_tiledimage_color2 skipped
export color3 tiledimage_color3(
    varying float2 texcoord=getGeomPropDef_UV0(),
    uniform texture_2d file=texture_2d()[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform color3 default_=color3(0.0, 0.0, 0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float2 uvtiling=float2(1.0, 1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float2 uvoffset=float2(0.0, 0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string filtertype=string("linear")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string framerange=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform int frameoffset=int(0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string frameendaction=string("black")[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx tiledimage"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    if(tex::texture_isvalid(file)) {
        return tex::lookup_color(
            file, (texcoord/uvtiling)-uvoffset);
    } else {
        return default_;
    }
}
// Unsupported MaterialX nodedef ND_tiledimage_color4 skipped
export float2 tiledimage_vector2(
    varying float2 texcoord=getGeomPropDef_UV0(),
    uniform texture_2d file=texture_2d()[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float2 default_=float2(0.0, 0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float2 uvtiling=float2(1.0, 1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float2 uvoffset=float2(0.0, 0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string filtertype=string("linear")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string framerange=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform int frameoffset=int(0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string frameendaction=string("black")[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx tiledimage"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    if(tex::texture_isvalid(file)) {
        return tex::lookup_float2(
            file, (texcoord/uvtiling)-uvoffset);
    } else {
        return default_;
    }
}
export float3 tiledimage_vector3(
    varying float2 texcoord=getGeomPropDef_UV0(),
    uniform texture_2d file=texture_2d()[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float3 default_=float3(0.0, 0.0, 0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float2 uvtiling=float2(1.0, 1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float2 uvoffset=float2(0.0, 0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string filtertype=string("linear")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string framerange=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform int frameoffset=int(0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string frameendaction=string("black")[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx tiledimage"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    if(tex::texture_isvalid(file)) {
        return tex::lookup_float3(
            file, (texcoord/uvtiling)-uvoffset);
    } else {
        return default_;
    }
}
export float4 tiledimage_vector4(
    varying float2 texcoord=getGeomPropDef_UV0(),
    uniform texture_2d file=texture_2d()[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float4 default_=float4(0.0, 0.0, 0.0, 0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float2 uvtiling=float2(1.0, 1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float2 uvoffset=float2(0.0, 0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string filtertype=string("linear")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string framerange=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform int frameoffset=int(0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string frameendaction=string("black")[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx tiledimage"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    if(tex::texture_isvalid(file)) {
        return tex::lookup_float4(
            file, (texcoord/uvtiling)-uvoffset);
    } else {
        return default_;
    }
}
export float triplanarprojection(
    varying float3 position=getGeomPropDef_Pobject(),
    varying float3 normal=getGeomPropDef_Nobject(),
    uniform texture_2d filex=texture_2d()[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform texture_2d filey=texture_2d()[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform texture_2d filez=texture_2d()[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string layerx=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string layery=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string layerz=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float default_=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string filtertype=string("linear")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string framerange=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform int frameoffset=int(0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string frameendaction=string("black")[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx triplanarprojection"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    float filex_val;
    if (tex::texture_isvalid(filex)) {
        filex_val = tex::lookup_float(
            filex, float2(position[1], position[2]));
    } else {
        filex_val = default_;
    }
    float filey_val;
    if (tex::texture_isvalid(filey)) {
        filey_val = tex::lookup_float(
            filey, float2(position[0], position[2]));
    } else {
        filey_val = default_;
    }
    float filez_val;
    if (tex::texture_isvalid(filez)) {
        filez_val = tex::lookup_float(
            filez, float2(position[0], position[1]));
    } else {
        filez_val = default_;
    }

    float3 blend = math::abs(math::normalize(normal));
    float accum =
        filex_val*blend.x + filey_val*blend.y + filez_val*blend.z;
    return accum/(blend.x+blend.y+blend.z);
}
// Unsupported MaterialX nodedef ND_triplanarprojection_color2 skipped
export color3 triplanarprojection(
    varying float3 position=getGeomPropDef_Pobject(),
    varying float3 normal=getGeomPropDef_Nobject(),
    uniform texture_2d filex=texture_2d()[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform texture_2d filey=texture_2d()[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform texture_2d filez=texture_2d()[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string layerx=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string layery=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string layerz=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform color3 default_=color3(0.0, 0.0, 0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string filtertype=string("linear")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string framerange=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform int frameoffset=int(0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string frameendaction=string("black")[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx triplanarprojection"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    color3 filex_val;
    if (tex::texture_isvalid(filex)) {
        filex_val = tex::lookup_color(
            filex, float2(position[1], position[2]));
    } else {
        filex_val = default_;
    }
    color3 filey_val;
    if (tex::texture_isvalid(filey)) {
        filey_val = tex::lookup_color(
            filey, float2(position[0], position[2]));
    } else {
        filey_val = default_;
    }
    color3 filez_val;
    if (tex::texture_isvalid(filez)) {
        filez_val = tex::lookup_color(
            filez, float2(position[0], position[1]));
    } else {
        filez_val = default_;
    }

    float3 blend = math::abs(math::normalize(normal));
    color3 accum =
        filex_val*blend.x + filey_val*blend.y + filez_val*blend.z;
    return accum/(blend.x+blend.y+blend.z);
}
// Unsupported MaterialX nodedef ND_triplanarprojection_color4 skipped
export float2 triplanarprojection(
    varying float3 position=getGeomPropDef_Pobject(),
    varying float3 normal=getGeomPropDef_Nobject(),
    uniform texture_2d filex=texture_2d()[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform texture_2d filey=texture_2d()[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform texture_2d filez=texture_2d()[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string layerx=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string layery=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string layerz=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float2 default_=float2(0.0, 0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string filtertype=string("linear")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string framerange=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform int frameoffset=int(0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string frameendaction=string("black")[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx triplanarprojection"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    float2 filex_val;
    if (tex::texture_isvalid(filex)) {
        filex_val = tex::lookup_float2(
            filex, float2(position[1], position[2]));
    } else {
        filex_val = default_;
    }
    float2 filey_val;
    if (tex::texture_isvalid(filey)) {
        filey_val = tex::lookup_float2(
            filey, float2(position[0], position[2]));
    } else {
        filey_val = default_;
    }
    float2 filez_val;
    if (tex::texture_isvalid(filez)) {
        filez_val = tex::lookup_float2(
            filez, float2(position[0], position[1]));
    } else {
        filez_val = default_;
    }

    float3 blend = math::abs(math::normalize(normal));
    float2 accum =
        filex_val*blend.x + filey_val*blend.y + filez_val*blend.z;
    return accum/(blend.x+blend.y+blend.z);
}
export float3 triplanarprojection(
    varying float3 position=getGeomPropDef_Pobject(),
    varying float3 normal=getGeomPropDef_Nobject(),
    uniform texture_2d filex=texture_2d()[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform texture_2d filey=texture_2d()[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform texture_2d filez=texture_2d()[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string layerx=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string layery=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string layerz=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float3 default_=float3(0.0, 0.0, 0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string filtertype=string("linear")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string framerange=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform int frameoffset=int(0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string frameendaction=string("black")[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx triplanarprojection"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    float3 filex_val;
    if (tex::texture_isvalid(filex)) {
        filex_val = tex::lookup_float3(
            filex, float2(position[1], position[2]));
    } else {
        filex_val = default_;
    }
    float3 filey_val;
    if (tex::texture_isvalid(filey)) {
        filey_val = tex::lookup_float3(
            filey, float2(position[0], position[2]));
    } else {
        filey_val = default_;
    }
    float3 filez_val;
    if (tex::texture_isvalid(filez)) {
        filez_val = tex::lookup_float3(
            filez, float2(position[0], position[1]));
    } else {
        filez_val = default_;
    }

    float3 blend = math::abs(math::normalize(normal));
    float3 accum =
        filex_val*blend.x + filey_val*blend.y + filez_val*blend.z;
    return accum/(blend.x+blend.y+blend.z);
}
export float4 triplanarprojection(
    varying float3 position=getGeomPropDef_Pobject(),
    varying float3 normal=getGeomPropDef_Nobject(),
    uniform texture_2d filex=texture_2d()[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform texture_2d filey=texture_2d()[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform texture_2d filez=texture_2d()[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string layerx=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string layery=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string layerz=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float4 default_=float4(0.0, 0.0, 0.0, 0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string filtertype=string("linear")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string framerange=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform int frameoffset=int(0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string frameendaction=string("black")[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx triplanarprojection"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    float4 filex_val;
    if (tex::texture_isvalid(filex)) {
        filex_val = tex::lookup_float4(
            filex, float2(position[1], position[2]));
    } else {
        filex_val = default_;
    }
    float4 filey_val;
    if (tex::texture_isvalid(filey)) {
        filey_val = tex::lookup_float4(
            filey, float2(position[0], position[2]));
    } else {
        filey_val = default_;
    }
    float4 filez_val;
    if (tex::texture_isvalid(filez)) {
        filez_val = tex::lookup_float4(
            filez, float2(position[0], position[1]));
    } else {
        filez_val = default_;
    }

    float3 blend = math::abs(math::normalize(normal));
    float4 accum =
        filex_val*blend.x + filey_val*blend.y + filez_val*blend.z;
    return accum/(blend.x+blend.y+blend.z);
}
export float constant(
    uniform float value=float(0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx constant"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return value;
}
// Unsupported MaterialX nodedef ND_constant_color2 skipped
export color3 constant(
    uniform color3 value=color3(0.f, 0.f, 0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx constant"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return value;
}
// Unsupported MaterialX nodedef ND_constant_color4 skipped
export float2 constant(
    uniform float2 value=float2(0.f,0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx constant"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return value;
}
export float3 constant(
    uniform float3 value=float3(0.f,0.f,0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx constant"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return value;
}
export float4 constant(
    uniform float4 value=float4(0.f,0.f,0.f,0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx constant"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return value;
}
export bool constant(
    uniform bool value=bool(false)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx constant"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return value;
}
export int constant(
    uniform int value=int(0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx constant"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return value;
}
export float3x3 constant(
    uniform float3x3 value=float3x3(0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx constant"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return value;
}
export float4x4 constant(
    uniform float4x4 value=float4x4(0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx constant"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return value;
}
export string constant(
    uniform string value=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx constant"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return value;
}
// skipping constant, cannot return texture_* types

export float ramplr(
    varying float2 texcoord=getGeomPropDef_UV0(),
    uniform float valuel=float(0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float valuer=float(0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx ramplr"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::lerp(valuel, valuer, math::clamp(texcoord.x, 0.0, 1.0));
}
// Unsupported MaterialX nodedef ND_ramplr_color2 skipped
export color3 ramplr(
    varying float2 texcoord=getGeomPropDef_UV0(),
    uniform color3 valuel=color3(0.f, 0.f, 0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform color3 valuer=color3(0.f, 0.f, 0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx ramplr"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::lerp(valuel, valuer, math::clamp(texcoord.x, 0.0, 1.0));
}
// Unsupported MaterialX nodedef ND_ramplr_color4 skipped
export float2 ramplr(
    varying float2 texcoord=getGeomPropDef_UV0(),
    uniform float2 valuel=float2(0.f,0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float2 valuer=float2(0.f,0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx ramplr"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::lerp(valuel, valuer, math::clamp(texcoord.x, 0.0, 1.0));
}
export float3 ramplr(
    varying float2 texcoord=getGeomPropDef_UV0(),
    uniform float3 valuel=float3(0.f,0.f,0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float3 valuer=float3(0.f,0.f,0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx ramplr"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::lerp(valuel, valuer, math::clamp(texcoord.x, 0.0, 1.0));
}
export float4 ramplr(
    varying float2 texcoord=getGeomPropDef_UV0(),
    uniform float4 valuel=float4(0.f,0.f,0.f,0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float4 valuer=float4(0.f,0.f,0.f,0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx ramplr"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::lerp(valuel, valuer, math::clamp(texcoord.x, 0.0, 1.0));
}
export float ramptb(
    varying float2 texcoord=getGeomPropDef_UV0(),
    uniform float valuet=float(0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float valueb=float(0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx ramptb"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::lerp(valuet, valueb, math::clamp(texcoord.y, 0.0, 1.0));
}
// Unsupported MaterialX nodedef ND_ramptb_color2 skipped
export color3 ramptb(
    varying float2 texcoord=getGeomPropDef_UV0(),
    uniform color3 valuet=color3(0.f, 0.f, 0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform color3 valueb=color3(0.f, 0.f, 0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx ramptb"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::lerp(valuet, valueb, math::clamp(texcoord.y, 0.0, 1.0));
}
// Unsupported MaterialX nodedef ND_ramptb_color4 skipped
export float2 ramptb(
    varying float2 texcoord=getGeomPropDef_UV0(),
    uniform float2 valuet=float2(0.f,0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float2 valueb=float2(0.f,0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx ramptb"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::lerp(valuet, valueb, math::clamp(texcoord.y, 0.0, 1.0));
}
export float3 ramptb(
    varying float2 texcoord=getGeomPropDef_UV0(),
    uniform float3 valuet=float3(0.f,0.f,0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float3 valueb=float3(0.f,0.f,0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx ramptb"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::lerp(valuet, valueb, math::clamp(texcoord.y, 0.0, 1.0));
}
export float4 ramptb(
    varying float2 texcoord=getGeomPropDef_UV0(),
    uniform float4 valuet=float4(0.f,0.f,0.f,0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float4 valueb=float4(0.f,0.f,0.f,0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx ramptb"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::lerp(valuet, valueb, math::clamp(texcoord.y, 0.0, 1.0));
}
export float ramp4(
    varying float2 texcoord=getGeomPropDef_UV0(),
    uniform float valuetl=float(0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float valuetr=float(0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float valuebl=float(0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float valuebr=float(0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx ramp4"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    float ss = math::clamp(texcoord.x, 0, 1);
    float tt = math::clamp(texcoord.y, 0, 1);
    return math::lerp(
        math::lerp(valuetl, valuetr, ss),
        math::lerp(valuebl, valuebr, ss), tt);
}
// Unsupported MaterialX nodedef ND_ramp4_color2 skipped
export color3 ramp4(
    varying float2 texcoord=getGeomPropDef_UV0(),
    uniform color3 valuetl=color3(0.f, 0.f, 0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform color3 valuetr=color3(0.f, 0.f, 0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform color3 valuebl=color3(0.f, 0.f, 0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform color3 valuebr=color3(0.f, 0.f, 0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx ramp4"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    float ss = math::clamp(texcoord.x, 0, 1);
    float tt = math::clamp(texcoord.y, 0, 1);
    return math::lerp(
        math::lerp(valuetl, valuetr, ss),
        math::lerp(valuebl, valuebr, ss), tt);
}
// Unsupported MaterialX nodedef ND_ramp4_color4 skipped
export float2 ramp4(
    varying float2 texcoord=getGeomPropDef_UV0(),
    uniform float2 valuetl=float2(0.f,0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float2 valuetr=float2(0.f,0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float2 valuebl=float2(0.f,0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float2 valuebr=float2(0.f,0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx ramp4"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    float ss = math::clamp(texcoord.x, 0, 1);
    float tt = math::clamp(texcoord.y, 0, 1);
    return math::lerp(
        math::lerp(valuetl, valuetr, ss),
        math::lerp(valuebl, valuebr, ss), tt);
}
export float3 ramp4(
    varying float2 texcoord=getGeomPropDef_UV0(),
    uniform float3 valuetl=float3(0.f,0.f,0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float3 valuetr=float3(0.f,0.f,0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float3 valuebl=float3(0.f,0.f,0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float3 valuebr=float3(0.f,0.f,0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx ramp4"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    float ss = math::clamp(texcoord.x, 0, 1);
    float tt = math::clamp(texcoord.y, 0, 1);
    return math::lerp(
        math::lerp(valuetl, valuetr, ss),
        math::lerp(valuebl, valuebr, ss), tt);
}
export float4 ramp4(
    varying float2 texcoord=getGeomPropDef_UV0(),
    uniform float4 valuetl=float4(0.f,0.f,0.f,0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float4 valuetr=float4(0.f,0.f,0.f,0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float4 valuebl=float4(0.f,0.f,0.f,0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float4 valuebr=float4(0.f,0.f,0.f,0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx ramp4"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    float ss = math::clamp(texcoord.x, 0, 1);
    float tt = math::clamp(texcoord.y, 0, 1);
    return math::lerp(
        math::lerp(valuetl, valuetr, ss),
        math::lerp(valuebl, valuebr, ss), tt);
}
export float splitlr(
    varying float2 texcoord=getGeomPropDef_UV0(),
    uniform float valuel=float(0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float valuer=float(0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float center=float(0.5)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx splitlr"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::lerp(valuel, valuer,
        math::step(center, math::clamp(texcoord.x,0,1)));
}
// Unsupported MaterialX nodedef ND_splitlr_color2 skipped
export color3 splitlr(
    varying float2 texcoord=getGeomPropDef_UV0(),
    uniform color3 valuel=color3(0.f, 0.f, 0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform color3 valuer=color3(0.f, 0.f, 0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float center=float(0.5)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx splitlr"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::lerp(valuel, valuer,
        math::step(center, math::clamp(texcoord.x,0,1)));
}
// Unsupported MaterialX nodedef ND_splitlr_color4 skipped
export float2 splitlr(
    varying float2 texcoord=getGeomPropDef_UV0(),
    uniform float2 valuel=float2(0.f,0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float2 valuer=float2(0.f,0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float center=float(0.5)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx splitlr"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::lerp(valuel, valuer,
        math::step(center, math::clamp(texcoord.x,0,1)));
}
export float3 splitlr(
    varying float2 texcoord=getGeomPropDef_UV0(),
    uniform float3 valuel=float3(0.f,0.f,0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float3 valuer=float3(0.f,0.f,0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float center=float(0.5)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx splitlr"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::lerp(valuel, valuer,
        math::step(center, math::clamp(texcoord.x,0,1)));
}
export float4 splitlr(
    varying float2 texcoord=getGeomPropDef_UV0(),
    uniform float4 valuel=float4(0.f,0.f,0.f,0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float4 valuer=float4(0.f,0.f,0.f,0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float center=float(0.5)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx splitlr"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::lerp(valuel, valuer,
        math::step(center, math::clamp(texcoord.x,0,1)));
}
export float splittb(
    varying float2 texcoord=getGeomPropDef_UV0(),
    uniform float valuet=float(0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float valueb=float(0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float center=float(0.5)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx splittb"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::lerp(valuet, valueb,
        math::step(center, math::clamp(texcoord.y,0,1)));
}
// Unsupported MaterialX nodedef ND_splittb_color2 skipped
export color3 splittb(
    varying float2 texcoord=getGeomPropDef_UV0(),
    uniform color3 valuet=color3(0.f, 0.f, 0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform color3 valueb=color3(0.f, 0.f, 0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float center=float(0.5)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx splittb"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::lerp(valuet, valueb,
        math::step(center, math::clamp(texcoord.y,0,1)));
}
// Unsupported MaterialX nodedef ND_splittb_color4 skipped
export float2 splittb(
    varying float2 texcoord=getGeomPropDef_UV0(),
    uniform float2 valuet=float2(0.f,0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float2 valueb=float2(0.f,0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float center=float(0.5)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx splittb"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::lerp(valuet, valueb,
        math::step(center, math::clamp(texcoord.y,0,1)));
}
export float3 splittb(
    varying float2 texcoord=getGeomPropDef_UV0(),
    uniform float3 valuet=float3(0.f,0.f,0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float3 valueb=float3(0.f,0.f,0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float center=float(0.5)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx splittb"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::lerp(valuet, valueb,
        math::step(center, math::clamp(texcoord.y,0,1)));
}
export float4 splittb(
    varying float2 texcoord=getGeomPropDef_UV0(),
    uniform float4 valuet=float4(0.f,0.f,0.f,0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float4 valueb=float4(0.f,0.f,0.f,0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float center=float(0.5)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx splittb"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::lerp(valuet, valueb,
        math::step(center, math::clamp(texcoord.y,0,1)));
}
export float noise2d_float(
    varying float2 texcoord=getGeomPropDef_UV0(),
    uniform float amplitude=float(1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float pivot=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx noise2d"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    float ns = float(mtlx::utilities::perlin_noise(texcoord));
    return float(amplitude)*(ns - float(pivot)) + float(pivot);
}
// Error: Implementation for color2 noise2d missing
/*export color2 noise2d_color2(
    varying float2 texcoord=getGeomPropDef_UV0(),
    uniform float2 amplitude=float2(1.0, 1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float pivot=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]]){ return color2(0.f, 0.f); }
*/
// Error: Implementation for color2 noise2d missing
/*export color2 noise2d_color2(
    varying float2 texcoord=getGeomPropDef_UV0(),
    uniform float amplitude=float(1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float pivot=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]]){ return color2(0.f, 0.f); }
*/
export color3 noise2d_color3(
    varying float2 texcoord=getGeomPropDef_UV0(),
    uniform float3 amplitude=float3(1.0, 1.0, 1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float pivot=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx noise2d"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    color3 ns = color3(mtlx::utilities::perlin_noise(texcoord));
    return color3(amplitude)*(ns - color3(pivot)) + color3(pivot);
}
export color3 noise2d_color3(
    varying float2 texcoord=getGeomPropDef_UV0(),
    uniform float amplitude=float(1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float pivot=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx noise2d"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    color3 ns = color3(mtlx::utilities::perlin_noise(texcoord));
    return color3(amplitude)*(ns - color3(pivot)) + color3(pivot);
}
// Error: Implementation for color4 noise2d missing
/*export color4 noise2d_color4(
    varying float2 texcoord=getGeomPropDef_UV0(),
    uniform float4 amplitude=float4(1.0, 1.0, 1.0, 1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float pivot=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]]){ return color4(0.f, 0.f, 0.f, 0.f); }
*/
// Error: Implementation for color4 noise2d missing
/*export color4 noise2d_color4(
    varying float2 texcoord=getGeomPropDef_UV0(),
    uniform float amplitude=float(1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float pivot=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]]){ return color4(0.f, 0.f, 0.f, 0.f); }
*/
export float2 noise2d_vector2(
    varying float2 texcoord=getGeomPropDef_UV0(),
    uniform float2 amplitude=float2(1.0, 1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float pivot=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx noise2d"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    float2 ns = float2(mtlx::utilities::perlin_noise(texcoord));
    return float2(amplitude)*(ns - float2(pivot)) + float2(pivot);
}
export float2 noise2d_vector2(
    varying float2 texcoord=getGeomPropDef_UV0(),
    uniform float amplitude=float(1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float pivot=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx noise2d"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    float2 ns = float2(mtlx::utilities::perlin_noise(texcoord));
    return float2(amplitude)*(ns - float2(pivot)) + float2(pivot);
}
export float3 noise2d_vector3(
    varying float2 texcoord=getGeomPropDef_UV0(),
    uniform float3 amplitude=float3(1.0, 1.0, 1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float pivot=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx noise2d"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    float3 ns = float3(mtlx::utilities::perlin_noise(texcoord));
    return float3(amplitude)*(ns - float3(pivot)) + float3(pivot);
}
export float3 noise2d_vector3(
    varying float2 texcoord=getGeomPropDef_UV0(),
    uniform float amplitude=float(1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float pivot=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx noise2d"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    float3 ns = float3(mtlx::utilities::perlin_noise(texcoord));
    return float3(amplitude)*(ns - float3(pivot)) + float3(pivot);
}
export float4 noise2d_vector4(
    varying float2 texcoord=getGeomPropDef_UV0(),
    uniform float4 amplitude=float4(1.0, 1.0, 1.0, 1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float pivot=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx noise2d"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    float4 ns = float4(mtlx::utilities::perlin_noise(texcoord));
    return float4(amplitude)*(ns - float4(pivot)) + float4(pivot);
}
export float4 noise2d_vector4(
    varying float2 texcoord=getGeomPropDef_UV0(),
    uniform float amplitude=float(1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float pivot=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx noise2d"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    float4 ns = float4(mtlx::utilities::perlin_noise(texcoord));
    return float4(amplitude)*(ns - float4(pivot)) + float4(pivot);
}
export float noise3d_float(
    varying float3 position=getGeomPropDef_Pobject(),
    uniform float amplitude=float(1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float pivot=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx noise3d"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    float ns = float(mtlx::utilities::perlin_noise(position));
    return float(amplitude)*(ns - float(pivot)) + float(pivot);
}
// Error: Implementation for color2 noise3d missing
/*export color2 noise3d_color2(
    varying float3 position=getGeomPropDef_Pobject(),
    uniform float2 amplitude=float2(1.0, 1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float pivot=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]]){ return color2(0.f, 0.f); }
*/
// Error: Implementation for color2 noise3d missing
/*export color2 noise3d_color2(
    varying float3 position=getGeomPropDef_Pobject(),
    uniform float amplitude=float(1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float pivot=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]]){ return color2(0.f, 0.f); }
*/
export color3 noise3d_color3(
    varying float3 position=getGeomPropDef_Pobject(),
    uniform float3 amplitude=float3(1.0, 1.0, 1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float pivot=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx noise3d"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    color3 ns = color3(mtlx::utilities::perlin_noise(position));
    return color3(amplitude)*(ns - color3(pivot)) + color3(pivot);
}
export color3 noise3d_color3(
    varying float3 position=getGeomPropDef_Pobject(),
    uniform float amplitude=float(1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float pivot=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx noise3d"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    color3 ns = color3(mtlx::utilities::perlin_noise(position));
    return color3(amplitude)*(ns - color3(pivot)) + color3(pivot);
}
// Error: Implementation for color4 noise3d missing
/*export color4 noise3d_color4(
    varying float3 position=getGeomPropDef_Pobject(),
    uniform float4 amplitude=float4(1.0, 1.0, 1.0, 1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float pivot=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]]){ return color4(0.f, 0.f, 0.f, 0.f); }
*/
// Error: Implementation for color4 noise3d missing
/*export color4 noise3d_color4(
    varying float3 position=getGeomPropDef_Pobject(),
    uniform float amplitude=float(1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float pivot=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]]){ return color4(0.f, 0.f, 0.f, 0.f); }
*/
export float2 noise3d_vector2(
    varying float3 position=getGeomPropDef_Pobject(),
    uniform float2 amplitude=float2(1.0, 1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float pivot=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx noise3d"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    float2 ns = float2(mtlx::utilities::perlin_noise(position));
    return float2(amplitude)*(ns - float2(pivot)) + float2(pivot);
}
export float2 noise3d_vector2(
    varying float3 position=getGeomPropDef_Pobject(),
    uniform float amplitude=float(1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float pivot=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx noise3d"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    float2 ns = float2(mtlx::utilities::perlin_noise(position));
    return float2(amplitude)*(ns - float2(pivot)) + float2(pivot);
}
export float3 noise3d_vector3(
    varying float3 position=getGeomPropDef_Pobject(),
    uniform float3 amplitude=float3(1.0, 1.0, 1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float pivot=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx noise3d"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    float3 ns = float3(mtlx::utilities::perlin_noise(position));
    return float3(amplitude)*(ns - float3(pivot)) + float3(pivot);
}
export float3 noise3d_vector3(
    varying float3 position=getGeomPropDef_Pobject(),
    uniform float amplitude=float(1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float pivot=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx noise3d"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    float3 ns = float3(mtlx::utilities::perlin_noise(position));
    return float3(amplitude)*(ns - float3(pivot)) + float3(pivot);
}
export float4 noise3d_vector4(
    varying float3 position=getGeomPropDef_Pobject(),
    uniform float4 amplitude=float4(1.0, 1.0, 1.0, 1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float pivot=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx noise3d"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    float4 ns = float4(mtlx::utilities::perlin_noise(position));
    return float4(amplitude)*(ns - float4(pivot)) + float4(pivot);
}
export float4 noise3d_vector4(
    varying float3 position=getGeomPropDef_Pobject(),
    uniform float amplitude=float(1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float pivot=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx noise3d"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    float4 ns = float4(mtlx::utilities::perlin_noise(position));
    return float4(amplitude)*(ns - float4(pivot)) + float4(pivot);
}
export float fractal3d_float(
    varying float3 position=getGeomPropDef_Pobject(),
    uniform float amplitude=float(1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform int octaves=int(3)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float lacunarity=float(2.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float diminish=float(0.5)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx fractal3d"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return mtlx::utilities::fBm_float(position, octaves, lacunarity, diminish) * amplitude;
}
// Error: Implementation for color2 fractal3d missing
/*export color2 fractal3d_color2(
    varying float3 position=getGeomPropDef_Pobject(),
    uniform float2 amplitude=float2(1.0, 1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform int octaves=int(3)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float lacunarity=float(2.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float diminish=float(0.5)[[
        alg::base::annotations::visible_by_default(false)
    ]]){ return color2(0.f, 0.f); }
*/
// Error: Implementation for color2 fractal3d missing
/*export color2 fractal3d_color2(
    varying float3 position=getGeomPropDef_Pobject(),
    uniform float amplitude=float(1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform int octaves=int(3)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float lacunarity=float(2.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float diminish=float(0.5)[[
        alg::base::annotations::visible_by_default(false)
    ]]){ return color2(0.f, 0.f); }
*/
export color3 fractal3d_color3(
    varying float3 position=getGeomPropDef_Pobject(),
    uniform float3 amplitude=float3(1.0, 1.0, 1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform int octaves=int(3)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float lacunarity=float(2.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float diminish=float(0.5)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx fractal3d"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return mtlx::utilities::fBm_color3(position, octaves, lacunarity, diminish) * amplitude;
}
export color3 fractal3d_color3(
    varying float3 position=getGeomPropDef_Pobject(),
    uniform float amplitude=float(1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform int octaves=int(3)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float lacunarity=float(2.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float diminish=float(0.5)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx fractal3d"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return mtlx::utilities::fBm_color3(position, octaves, lacunarity, diminish) * amplitude;
}
// Error: Implementation for color4 fractal3d missing
/*export color4 fractal3d_color4(
    varying float3 position=getGeomPropDef_Pobject(),
    uniform float4 amplitude=float4(1.0, 1.0, 1.0, 1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform int octaves=int(3)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float lacunarity=float(2.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float diminish=float(0.5)[[
        alg::base::annotations::visible_by_default(false)
    ]]){ return color4(0.f, 0.f, 0.f, 0.f); }
*/
// Error: Implementation for color4 fractal3d missing
/*export color4 fractal3d_color4(
    varying float3 position=getGeomPropDef_Pobject(),
    uniform float amplitude=float(1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform int octaves=int(3)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float lacunarity=float(2.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float diminish=float(0.5)[[
        alg::base::annotations::visible_by_default(false)
    ]]){ return color4(0.f, 0.f, 0.f, 0.f); }
*/
export float2 fractal3d_vector2(
    varying float3 position=getGeomPropDef_Pobject(),
    uniform float2 amplitude=float2(1.0, 1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform int octaves=int(3)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float lacunarity=float(2.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float diminish=float(0.5)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx fractal3d"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return mtlx::utilities::fBm_float2(position, octaves, lacunarity, diminish) * amplitude;
}
export float2 fractal3d_vector2(
    varying float3 position=getGeomPropDef_Pobject(),
    uniform float amplitude=float(1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform int octaves=int(3)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float lacunarity=float(2.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float diminish=float(0.5)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx fractal3d"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return mtlx::utilities::fBm_float2(position, octaves, lacunarity, diminish) * amplitude;
}
export float3 fractal3d_vector3(
    varying float3 position=getGeomPropDef_Pobject(),
    uniform float3 amplitude=float3(1.0, 1.0, 1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform int octaves=int(3)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float lacunarity=float(2.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float diminish=float(0.5)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx fractal3d"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return mtlx::utilities::fBm_float3(position, octaves, lacunarity, diminish) * amplitude;
}
export float3 fractal3d_vector3(
    varying float3 position=getGeomPropDef_Pobject(),
    uniform float amplitude=float(1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform int octaves=int(3)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float lacunarity=float(2.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float diminish=float(0.5)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx fractal3d"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return mtlx::utilities::fBm_float3(position, octaves, lacunarity, diminish) * amplitude;
}
export float4 fractal3d_vector4(
    varying float3 position=getGeomPropDef_Pobject(),
    uniform float4 amplitude=float4(1.0, 1.0, 1.0, 1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform int octaves=int(3)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float lacunarity=float(2.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float diminish=float(0.5)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx fractal3d"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return mtlx::utilities::fBm_float4(position, octaves, lacunarity, diminish) * amplitude;
}
export float4 fractal3d_vector4(
    varying float3 position=getGeomPropDef_Pobject(),
    uniform float amplitude=float(1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform int octaves=int(3)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float lacunarity=float(2.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float diminish=float(0.5)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx fractal3d"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return mtlx::utilities::fBm_float4(position, octaves, lacunarity, diminish) * amplitude;
}
export float cellnoise2d(
    varying float2 texcoord=getGeomPropDef_UV0())
[[
    anno::display_name("Matx cellnoise2d"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return mtlx::utilities::cellnoise(texcoord);
}
export float cellnoise3d(
    varying float3 position=getGeomPropDef_Pobject())
[[
    anno::display_name("Matx cellnoise3d"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return mtlx::utilities::cellnoise(position);
}
export float3 position(
    uniform string space=string("object")[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx position"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return state::transform_point(state::coordinate_internal, mtlx::utilities::getSpaceByString(space), state::position());
}
export float3 normal(
    uniform string space=string("object")[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx normal"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return state::transform_normal(state::coordinate_internal, mtlx::utilities::getSpaceByString(space), state::normal());
}
export float3 tangent(
    uniform string space=string("object")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform int index=int(0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx tangent"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return state::transform_vector(state::coordinate_internal, mtlx::utilities::getSpaceByString(space), state::texture_tangent_u(index));
}
export float3 bitangent(
    uniform string space=string("object")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform int index=int(0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx bitangent"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return state::transform_vector(state::coordinate_internal, mtlx::utilities::getSpaceByString(space), state::texture_tangent_v(index));
}
export float2 texcoord_vector2(
    uniform int index=int(0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx texcoord"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    float3 tmp = state::texture_coordinate(index);
    return float2(tmp[0],tmp[1]);
}
export float3 texcoord_vector3(
    uniform int index=int(0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx texcoord"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return (state::texture_coordinate(index));
}
export float geomcolor_float(
    uniform int index=int(0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx geomcolor"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return float(0.f);
}
// Error: Implementation for color2 geomcolor missing
/*export color2 geomcolor_color2(
    uniform int index=int(0)[[
        alg::base::annotations::visible_by_default(false)
    ]]){ return color2(0.f, 0.f); }
*/
export color3 geomcolor_color3(
    uniform int index=int(0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx geomcolor"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return color3(0.f, 0.f, 0.f);
}
// Error: Implementation for color4 geomcolor missing
/*export color4 geomcolor_color4(
    uniform int index=int(0)[[
        alg::base::annotations::visible_by_default(false)
    ]]){ return color4(0.f, 0.f, 0.f, 0.f); }
*/
export int geomattrvalue_integer(
    uniform string attrname=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx geomattrvalue"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return int(0);
}
export bool geomattrvalue_boolean(
    uniform string attrname=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx geomattrvalue"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return bool(false);
}
export string geomattrvalue_string(
    uniform string attrname=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx geomattrvalue"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return string("");
}
export float geomattrvalue_float(
    uniform string attrname=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx geomattrvalue"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return float(0.f);
}
// Error: Implementation for color2 geomattrvalue missing
/*export color2 geomattrvalue_color2(
    uniform string attrname=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]]){ return color2(0.f, 0.f); }
*/
export color3 geomattrvalue_color3(
    uniform string attrname=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx geomattrvalue"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return color3(0.f, 0.f, 0.f);
}
// Error: Implementation for color4 geomattrvalue missing
/*export color4 geomattrvalue_color4(
    uniform string attrname=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]]){ return color4(0.f, 0.f, 0.f, 0.f); }
*/
export float2 geomattrvalue_vector2(
    uniform string attrname=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx geomattrvalue"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return float2(0.f,0.f);
}
export float3 geomattrvalue_vector3(
    uniform string attrname=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx geomattrvalue"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return float3(0.f,0.f,0.f);
}
export float4 geomattrvalue_vector4(
    uniform string attrname=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx geomattrvalue"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return float4(0.f,0.f,0.f,0.f);
}
// Error: Implementation for float ambientocclusion missing
/*export float ambientocclusion(
    uniform float coneangle=float(90.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float maxdistance=float(1e38)[[
        alg::base::annotations::visible_by_default(false)
    ]]){ return float(0.f); }
*/
// Error: Implementation for float frame missing
/*export float frame(
    ){ return float(0.f); }
*/
export float time(
    uniform float fps=float(24.0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx time"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return state::animation_time();
}
// Error: Implementation for float3 viewdirection missing
/*export float3 viewdirection(
    uniform string space=string("world")[[
        alg::base::annotations::visible_by_default(false)
    ]]){ return float3(0.f,0.f,0.f); }
*/
export float add(
    varying float in1=float(0.f),
    varying float in2=float(0.f))
[[
    anno::display_name("Matx add"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return (in1 + float(in2));
}
// Unsupported MaterialX nodedef ND_add_color2 skipped
// Unsupported MaterialX nodedef ND_add_color2FA skipped
export color3 add(
    varying color3 in1=color3(0.f, 0.f, 0.f),
    varying color3 in2=color3(0.f, 0.f, 0.f))
[[
    anno::display_name("Matx add"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return (in1 + color3(in2));
}
export color3 add(
    varying color3 in1=color3(0.f, 0.f, 0.f),
    varying float in2=float(0.f))
[[
    anno::display_name("Matx add"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return (in1 + color3(in2));
}
// Unsupported MaterialX nodedef ND_add_color4 skipped
// Unsupported MaterialX nodedef ND_add_color4FA skipped
export float2 add(
    varying float2 in1=float2(0.f,0.f),
    varying float2 in2=float2(0.f,0.f))
[[
    anno::display_name("Matx add"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return (in1 + float2(in2));
}
export float2 add(
    varying float2 in1=float2(0.f,0.f),
    varying float in2=float(0.f))
[[
    anno::display_name("Matx add"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return (in1 + float2(in2));
}
export float3 add(
    varying float3 in1=float3(0.f,0.f,0.f),
    varying float3 in2=float3(0.f,0.f,0.f))
[[
    anno::display_name("Matx add"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return (in1 + float3(in2));
}
export float3 add(
    varying float3 in1=float3(0.f,0.f,0.f),
    varying float in2=float(0.f))
[[
    anno::display_name("Matx add"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return (in1 + float3(in2));
}
export float4 add(
    varying float4 in1=float4(0.f,0.f,0.f,0.f),
    varying float4 in2=float4(0.f,0.f,0.f,0.f))
[[
    anno::display_name("Matx add"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return (in1 + float4(in2));
}
export float4 add(
    varying float4 in1=float4(0.f,0.f,0.f,0.f),
    varying float in2=float(0.f))
[[
    anno::display_name("Matx add"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return (in1 + float4(in2));
}
export float3x3 add(
    varying float3x3 in1=float3x3(0.f),
    varying float3x3 in2=float3x3(0.f))
[[
    anno::display_name("Matx add"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return (in1 + float3x3(in2));
}
export float3x3 add(
    varying float3x3 in1=float3x3(0.f),
    varying float in2=float(0.f))
[[
    anno::display_name("Matx add"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return (in1 + float3x3(in2));
}
export float4x4 add(
    varying float4x4 in1=float4x4(0.f),
    varying float4x4 in2=float4x4(0.f))
[[
    anno::display_name("Matx add"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return (in1 + float4x4(in2));
}
export float4x4 add(
    varying float4x4 in1=float4x4(0.f),
    varying float in2=float(0.f))
[[
    anno::display_name("Matx add"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return (in1 + float4x4(in2));
}
// Error: material type nodes are dummy implemented
/*export material add(
    varying material in1=material(),
    varying material in2=material())=mtlx::utilities::dummyMaterial();
*/
// Unsupported MaterialX nodedef ND_add_displacementshader skipped
// Unsupported MaterialX nodedef ND_add_volumeshader skipped
export float subtract(
    varying float in1=float(0.f),
    varying float in2=float(0.f))
[[
    anno::display_name("Matx subtract"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return (in1 - float(in2));
}
// Unsupported MaterialX nodedef ND_subtract_color2 skipped
// Unsupported MaterialX nodedef ND_subtract_color2FA skipped
export color3 subtract(
    varying color3 in1=color3(0.f, 0.f, 0.f),
    varying color3 in2=color3(0.f, 0.f, 0.f))
[[
    anno::display_name("Matx subtract"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return (in1 - color3(in2));
}
export color3 subtract(
    varying color3 in1=color3(0.f, 0.f, 0.f),
    varying float in2=float(0.f))
[[
    anno::display_name("Matx subtract"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return (in1 - color3(in2));
}
// Unsupported MaterialX nodedef ND_subtract_color4 skipped
// Unsupported MaterialX nodedef ND_subtract_color4FA skipped
export float2 subtract(
    varying float2 in1=float2(0.f,0.f),
    varying float2 in2=float2(0.f,0.f))
[[
    anno::display_name("Matx subtract"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return (in1 - float2(in2));
}
export float2 subtract(
    varying float2 in1=float2(0.f,0.f),
    varying float in2=float(0.f))
[[
    anno::display_name("Matx subtract"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return (in1 - float2(in2));
}
export float3 subtract(
    varying float3 in1=float3(0.f,0.f,0.f),
    varying float3 in2=float3(0.f,0.f,0.f))
[[
    anno::display_name("Matx subtract"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return (in1 - float3(in2));
}
export float3 subtract(
    varying float3 in1=float3(0.f,0.f,0.f),
    varying float in2=float(0.f))
[[
    anno::display_name("Matx subtract"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return (in1 - float3(in2));
}
export float4 subtract(
    varying float4 in1=float4(0.f,0.f,0.f,0.f),
    varying float4 in2=float4(0.f,0.f,0.f,0.f))
[[
    anno::display_name("Matx subtract"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return (in1 - float4(in2));
}
export float4 subtract(
    varying float4 in1=float4(0.f,0.f,0.f,0.f),
    varying float in2=float(0.f))
[[
    anno::display_name("Matx subtract"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return (in1 - float4(in2));
}
export float3x3 subtract(
    varying float3x3 in1=float3x3(0.f),
    varying float3x3 in2=float3x3(0.f))
[[
    anno::display_name("Matx subtract"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return (in1 - float3x3(in2));
}
export float3x3 subtract(
    varying float3x3 in1=float3x3(0.f),
    varying float in2=float(0.f))
[[
    anno::display_name("Matx subtract"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return (in1 - float3x3(in2));
}
export float4x4 subtract(
    varying float4x4 in1=float4x4(0.f),
    varying float4x4 in2=float4x4(0.f))
[[
    anno::display_name("Matx subtract"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return (in1 - float4x4(in2));
}
export float4x4 subtract(
    varying float4x4 in1=float4x4(0.f),
    varying float in2=float(0.f))
[[
    anno::display_name("Matx subtract"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return (in1 - float4x4(in2));
}
export float multiply(
    varying float in1=float(0.f),
    varying float in2=float(0.f))
[[
    anno::display_name("Matx multiply"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return (in1 * float(in2));
}
// Unsupported MaterialX nodedef ND_multiply_color2 skipped
// Unsupported MaterialX nodedef ND_multiply_color2FA skipped
export color3 multiply(
    varying color3 in1=color3(0.f, 0.f, 0.f),
    varying color3 in2=color3(0.f, 0.f, 0.f))
[[
    anno::display_name("Matx multiply"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return (in1 * color3(in2));
}
export color3 multiply(
    varying color3 in1=color3(0.f, 0.f, 0.f),
    varying float in2=float(0.f))
[[
    anno::display_name("Matx multiply"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return (in1 * color3(in2));
}
// Unsupported MaterialX nodedef ND_multiply_color4 skipped
// Unsupported MaterialX nodedef ND_multiply_color4FA skipped
export float2 multiply(
    varying float2 in1=float2(0.f,0.f),
    varying float2 in2=float2(0.f,0.f))
[[
    anno::display_name("Matx multiply"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return (in1 * float2(in2));
}
export float2 multiply(
    varying float2 in1=float2(0.f,0.f),
    varying float in2=float(0.f))
[[
    anno::display_name("Matx multiply"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return (in1 * float2(in2));
}
export float3 multiply(
    varying float3 in1=float3(0.f,0.f,0.f),
    varying float3 in2=float3(0.f,0.f,0.f))
[[
    anno::display_name("Matx multiply"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return (in1 * float3(in2));
}
export float3 multiply(
    varying float3 in1=float3(0.f,0.f,0.f),
    varying float in2=float(0.f))
[[
    anno::display_name("Matx multiply"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return (in1 * float3(in2));
}
export float4 multiply(
    varying float4 in1=float4(0.f,0.f,0.f,0.f),
    varying float4 in2=float4(0.f,0.f,0.f,0.f))
[[
    anno::display_name("Matx multiply"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return (in1 * float4(in2));
}
export float4 multiply(
    varying float4 in1=float4(0.f,0.f,0.f,0.f),
    varying float in2=float(0.f))
[[
    anno::display_name("Matx multiply"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return (in1 * float4(in2));
}
export float3x3 multiply(
    varying float3x3 in1=float3x3(0.f),
    varying float3x3 in2=float3x3(0.f))
[[
    anno::display_name("Matx multiply"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return (in1 * float3x3(in2));
}
export float4x4 multiply(
    varying float4x4 in1=float4x4(0.f),
    varying float4x4 in2=float4x4(0.f))
[[
    anno::display_name("Matx multiply"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return (in1 * float4x4(in2));
}
// Error: material type nodes are dummy implemented
// Error: material multiplication polymorphy not implemented
/*export material multiply(
    varying material in1=material(),
    varying float in2=float(0.f))=mtlx::utilities::dummyMaterial();
*/
// Error: material type nodes are dummy implemented
// Error: material multiplication polymorphy not implemented
/*export material multiply(
    varying material in1=material(),
    varying color3 in2=color3(0.f, 0.f, 0.f))=mtlx::utilities::dummyMaterial();
*/
// Unsupported MaterialX nodedef ND_multiply_displacementshaderF skipped
// Unsupported MaterialX nodedef ND_multiply_displacementshaderV skipped
// Unsupported MaterialX nodedef ND_multiply_volumeshaderF skipped
// Unsupported MaterialX nodedef ND_multiply_volumeshaderC skipped
export float divide(
    varying float in1=float(0.f),
    varying float in2=float(0.f))
[[
    anno::display_name("Matx divide"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return (in1 / float(in2));
}
// Unsupported MaterialX nodedef ND_divide_color2 skipped
// Unsupported MaterialX nodedef ND_divide_color2FA skipped
export color3 divide(
    varying color3 in1=color3(0.f, 0.f, 0.f),
    varying color3 in2=color3(0.f, 0.f, 0.f))
[[
    anno::display_name("Matx divide"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return (in1 / color3(in2));
}
export color3 divide(
    varying color3 in1=color3(0.f, 0.f, 0.f),
    varying float in2=float(0.f))
[[
    anno::display_name("Matx divide"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return (in1 / color3(in2));
}
// Unsupported MaterialX nodedef ND_divide_color4 skipped
// Unsupported MaterialX nodedef ND_divide_color4FA skipped
export float2 divide(
    varying float2 in1=float2(0.f,0.f),
    varying float2 in2=float2(0.f,0.f))
[[
    anno::display_name("Matx divide"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return (in1 / float2(in2));
}
export float2 divide(
    varying float2 in1=float2(0.f,0.f),
    varying float in2=float(0.f))
[[
    anno::display_name("Matx divide"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return (in1 / float2(in2));
}
export float3 divide(
    varying float3 in1=float3(0.f,0.f,0.f),
    varying float3 in2=float3(0.f,0.f,0.f))
[[
    anno::display_name("Matx divide"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return (in1 / float3(in2));
}
export float3 divide(
    varying float3 in1=float3(0.f,0.f,0.f),
    varying float in2=float(0.f))
[[
    anno::display_name("Matx divide"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return (in1 / float3(in2));
}
export float4 divide(
    varying float4 in1=float4(0.f,0.f,0.f,0.f),
    varying float4 in2=float4(0.f,0.f,0.f,0.f))
[[
    anno::display_name("Matx divide"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return (in1 / float4(in2));
}
export float4 divide(
    varying float4 in1=float4(0.f,0.f,0.f,0.f),
    varying float in2=float(0.f))
[[
    anno::display_name("Matx divide"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return (in1 / float4(in2));
}
// Error: Implementation for float3x3 divide missing
/*export float3x3 divide(
    varying float3x3 in1=float3x3(0.f),
    varying float3x3 in2=float3x3(0.f)){ return float3x3(0.f); }
*/
// Error: Implementation for float4x4 divide missing
/*export float4x4 divide(
    varying float4x4 in1=float4x4(0.f),
    varying float4x4 in2=float4x4(0.f)){ return float4x4(0.f); }
*/
export float modulo(
    varying float in1=float(0.f),
    varying float in2=float(0.f))
[[
    anno::display_name("Matx modulo"),
    anno::description("The remaining fraction after dividing the incoming float/color/vector by the constant amount and subtracting the integer portion. The modulo amount cannot be 0. MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::fmod(in1, in2);
}
// Unsupported MaterialX nodedef ND_modulo_color2 skipped
// Unsupported MaterialX nodedef ND_modulo_color2FA skipped
export color3 modulo(
    varying color3 in1=color3(0.f, 0.f, 0.f),
    varying color3 in2=color3(0.f, 0.f, 0.f))
[[
    anno::display_name("Matx modulo"),
    anno::description("The remaining fraction after dividing the incoming float/color/vector by the constant amount and subtracting the integer portion. The modulo amount cannot be 0. MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return color3(math::fmod(float3(in1), float3(in2)));
}
export color3 modulo(
    varying color3 in1=color3(0.f, 0.f, 0.f),
    varying float in2=float(0.f))
[[
    anno::display_name("Matx modulo"),
    anno::description("The remaining fraction after dividing the incoming float/color/vector by the constant amount and subtracting the integer portion. The modulo amount cannot be 0. MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return color3(math::fmod(float3(in1), float3(in2)));
}
// Unsupported MaterialX nodedef ND_modulo_color4 skipped
// Unsupported MaterialX nodedef ND_modulo_color4FA skipped
export float2 modulo(
    varying float2 in1=float2(0.f,0.f),
    varying float2 in2=float2(0.f,0.f))
[[
    anno::display_name("Matx modulo"),
    anno::description("The remaining fraction after dividing the incoming float/color/vector by the constant amount and subtracting the integer portion. The modulo amount cannot be 0. MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::fmod(in1, in2);
}
export float2 modulo(
    varying float2 in1=float2(0.f,0.f),
    varying float in2=float(0.f))
[[
    anno::display_name("Matx modulo"),
    anno::description("The remaining fraction after dividing the incoming float/color/vector by the constant amount and subtracting the integer portion. The modulo amount cannot be 0. MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::fmod(in1, in2);
}
export float3 modulo(
    varying float3 in1=float3(0.f,0.f,0.f),
    varying float3 in2=float3(0.f,0.f,0.f))
[[
    anno::display_name("Matx modulo"),
    anno::description("The remaining fraction after dividing the incoming float/color/vector by the constant amount and subtracting the integer portion. The modulo amount cannot be 0. MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::fmod(in1, in2);
}
export float3 modulo(
    varying float3 in1=float3(0.f,0.f,0.f),
    varying float in2=float(0.f))
[[
    anno::display_name("Matx modulo"),
    anno::description("The remaining fraction after dividing the incoming float/color/vector by the constant amount and subtracting the integer portion. The modulo amount cannot be 0. MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::fmod(in1, in2);
}
export float4 modulo(
    varying float4 in1=float4(0.f,0.f,0.f,0.f),
    varying float4 in2=float4(0.f,0.f,0.f,0.f))
[[
    anno::display_name("Matx modulo"),
    anno::description("The remaining fraction after dividing the incoming float/color/vector by the constant amount and subtracting the integer portion. The modulo amount cannot be 0. MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::fmod(in1, in2);
}
export float4 modulo(
    varying float4 in1=float4(0.f,0.f,0.f,0.f),
    varying float in2=float(0.f))
[[
    anno::display_name("Matx modulo"),
    anno::description("The remaining fraction after dividing the incoming float/color/vector by the constant amount and subtracting the integer portion. The modulo amount cannot be 0. MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::fmod(in1, in2);
}
export float invert(
    varying float in_=float(0.f),
    uniform float amount=float(1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx invert"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return float(amount) - in_;
}
// Unsupported MaterialX nodedef ND_invert_color2 skipped
// Unsupported MaterialX nodedef ND_invert_color2FA skipped
export color3 invert(
    varying color3 in_=color3(0.f, 0.f, 0.f),
    uniform color3 amount=color3(1.0, 1.0, 1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx invert"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return color3(amount) - in_;
}
export color3 invert(
    varying color3 in_=color3(0.f, 0.f, 0.f),
    uniform float amount=float(1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx invert"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return color3(amount) - in_;
}
// Unsupported MaterialX nodedef ND_invert_color4 skipped
// Unsupported MaterialX nodedef ND_invert_color4FA skipped
export float2 invert(
    varying float2 in_=float2(0.f,0.f),
    uniform float2 amount=float2(1.0, 1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx invert"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return float2(amount) - in_;
}
export float2 invert(
    varying float2 in_=float2(0.f,0.f),
    uniform float amount=float(1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx invert"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return float2(amount) - in_;
}
export float3 invert(
    varying float3 in_=float3(0.f,0.f,0.f),
    uniform float3 amount=float3(1.0, 1.0, 1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx invert"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return float3(amount) - in_;
}
export float3 invert(
    varying float3 in_=float3(0.f,0.f,0.f),
    uniform float amount=float(1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx invert"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return float3(amount) - in_;
}
export float4 invert(
    varying float4 in_=float4(0.f,0.f,0.f,0.f),
    uniform float4 amount=float4(1.0, 1.0, 1.0, 1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx invert"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return float4(amount) - in_;
}
export float4 invert(
    varying float4 in_=float4(0.f,0.f,0.f,0.f),
    uniform float amount=float(1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx invert"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return float4(amount) - in_;
}
// Error: Implementation for float3x3 invert missing
/*export float3x3 invert(
    varying float3x3 in_=float3x3(0.f)){ return float3x3(0.f); }
*/
// Error: Implementation for float4x4 invert missing
/*export float4x4 invert(
    varying float4x4 in_=float4x4(0.f)){ return float4x4(0.f); }
*/
export float absval(
    varying float in_=float(0.f))
[[
    anno::display_name("Matx absval"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::abs(in_);
}
// Unsupported MaterialX nodedef ND_absval_color2 skipped
export color3 absval(
    varying color3 in_=color3(0.f, 0.f, 0.f))
[[
    anno::display_name("Matx absval"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return color3(math::abs(float3(in_)));
}
// Unsupported MaterialX nodedef ND_absval_color4 skipped
export float2 absval(
    varying float2 in_=float2(0.f,0.f))
[[
    anno::display_name("Matx absval"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::abs(in_);
}
export float3 absval(
    varying float3 in_=float3(0.f,0.f,0.f))
[[
    anno::display_name("Matx absval"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::abs(in_);
}
export float4 absval(
    varying float4 in_=float4(0.f,0.f,0.f,0.f))
[[
    anno::display_name("Matx absval"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::abs(in_);
}
export float floor(
    varying float in_=float(0.f))
[[
    anno::display_name("Matx floor"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::floor(in_);
}
// Unsupported MaterialX nodedef ND_floor_color2 skipped
export color3 floor(
    varying color3 in_=color3(0.f, 0.f, 0.f))
[[
    anno::display_name("Matx floor"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return color3(math::floor(float3(in_)));
}
// Unsupported MaterialX nodedef ND_floor_color4 skipped
export float2 floor(
    varying float2 in_=float2(0.f,0.f))
[[
    anno::display_name("Matx floor"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::floor(in_);
}
export float3 floor(
    varying float3 in_=float3(0.f,0.f,0.f))
[[
    anno::display_name("Matx floor"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::floor(in_);
}
export float4 floor(
    varying float4 in_=float4(0.f,0.f,0.f,0.f))
[[
    anno::display_name("Matx floor"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::floor(in_);
}
export float ceil(
    varying float in_=float(0.f))
[[
    anno::display_name("Matx ceil"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::ceil(in_);
}
// Unsupported MaterialX nodedef ND_ceil_color2 skipped
export color3 ceil(
    varying color3 in_=color3(0.f, 0.f, 0.f))
[[
    anno::display_name("Matx ceil"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return color3(math::ceil(float3(in_)));
}
// Unsupported MaterialX nodedef ND_ceil_color4 skipped
export float2 ceil(
    varying float2 in_=float2(0.f,0.f))
[[
    anno::display_name("Matx ceil"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::ceil(in_);
}
export float3 ceil(
    varying float3 in_=float3(0.f,0.f,0.f))
[[
    anno::display_name("Matx ceil"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::ceil(in_);
}
export float4 ceil(
    varying float4 in_=float4(0.f,0.f,0.f,0.f))
[[
    anno::display_name("Matx ceil"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::ceil(in_);
}
export float power(
    varying float in1=float(0.f),
    varying float in2=float(0.f))
[[
    anno::display_name("Matx power"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::pow(in1, float(in2));
}
// Unsupported MaterialX nodedef ND_power_color2 skipped
// Unsupported MaterialX nodedef ND_power_color2FA skipped
export color3 power(
    varying color3 in1=color3(0.f, 0.f, 0.f),
    varying color3 in2=color3(0.f, 0.f, 0.f))
[[
    anno::display_name("Matx power"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::pow(in1, color3(in2));
}
export color3 power(
    varying color3 in1=color3(0.f, 0.f, 0.f),
    varying float in2=float(0.f))
[[
    anno::display_name("Matx power"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::pow(in1, color3(in2));
}
// Unsupported MaterialX nodedef ND_power_color4 skipped
// Unsupported MaterialX nodedef ND_power_color4FA skipped
export float2 power(
    varying float2 in1=float2(0.f,0.f),
    varying float2 in2=float2(0.f,0.f))
[[
    anno::display_name("Matx power"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::pow(in1, float2(in2));
}
export float2 power(
    varying float2 in1=float2(0.f,0.f),
    varying float in2=float(0.f))
[[
    anno::display_name("Matx power"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::pow(in1, float2(in2));
}
export float3 power(
    varying float3 in1=float3(0.f,0.f,0.f),
    varying float3 in2=float3(0.f,0.f,0.f))
[[
    anno::display_name("Matx power"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::pow(in1, float3(in2));
}
export float3 power(
    varying float3 in1=float3(0.f,0.f,0.f),
    varying float in2=float(0.f))
[[
    anno::display_name("Matx power"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::pow(in1, float3(in2));
}
export float4 power(
    varying float4 in1=float4(0.f,0.f,0.f,0.f),
    varying float4 in2=float4(0.f,0.f,0.f,0.f))
[[
    anno::display_name("Matx power"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::pow(in1, float4(in2));
}
export float4 power(
    varying float4 in1=float4(0.f,0.f,0.f,0.f),
    varying float in2=float(0.f))
[[
    anno::display_name("Matx power"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::pow(in1, float4(in2));
}
export float sin(
    varying float in_=float(0.f))
[[
    anno::display_name("Matx sin"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::sin(in_);
}
export float cos(
    varying float in_=float(0.f))
[[
    anno::display_name("Matx cos"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::cos(in_);
}
export float tan(
    varying float in_=float(0.f))
[[
    anno::display_name("Matx tan"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::tan(in_);
}
export float asin(
    varying float in_=float(0.f))
[[
    anno::display_name("Matx asin"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::asin(in_);
}
export float acos(
    varying float in_=float(0.f))
[[
    anno::display_name("Matx acos"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::acos(in_);
}
// Error: Implementation for float atan2 missing
/*export float atan2(
    varying float in1=float(0.f),
    varying float in2=float(0.f)){ return float(0.f); }
*/
export float sqrt(
    varying float in_=float(0.f))
[[
    anno::display_name("Matx sqrt"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::sqrt(in_);
}
export float ln(
    varying float in_=float(0.f))
[[
    anno::display_name("Matx ln"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::log(in_);
}
export float exp(
    varying float in_=float(0.f))
[[
    anno::display_name("Matx exp"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::exp(in_);
}
export float sign(
    varying float in_=float(0.f))
[[
    anno::display_name("Matx sign"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::sign(in_);
}
// Unsupported MaterialX nodedef ND_sign_color2 skipped
export color3 sign(
    varying color3 in_=color3(0.f, 0.f, 0.f))
[[
    anno::display_name("Matx sign"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return color3(math::sign(float3(in_)));
}
// Unsupported MaterialX nodedef ND_sign_color4 skipped
export float2 sign(
    varying float2 in_=float2(0.f,0.f))
[[
    anno::display_name("Matx sign"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::sign(in_);
}
export float3 sign(
    varying float3 in_=float3(0.f,0.f,0.f))
[[
    anno::display_name("Matx sign"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::sign(in_);
}
export float4 sign(
    varying float4 in_=float4(0.f,0.f,0.f,0.f))
[[
    anno::display_name("Matx sign"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::sign(in_);
}
export float clamp(
    varying float in_=float(0.f),
    uniform float low=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float high=float(1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx clamp"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::clamp(in_, low, high);
}
// Unsupported MaterialX nodedef ND_clamp_color2 skipped
// Unsupported MaterialX nodedef ND_clamp_color2FA skipped
export color3 clamp(
    varying color3 in_=color3(0.f, 0.f, 0.f),
    uniform color3 low=color3(0.0, 0.0, 0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform color3 high=color3(1.0, 1.0, 1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx clamp"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::clamp(in_, low, high);
}
export color3 clamp(
    varying color3 in_=color3(0.f, 0.f, 0.f),
    uniform float low=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float high=float(1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx clamp"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::clamp(in_, low, high);
}
// Unsupported MaterialX nodedef ND_clamp_color4 skipped
// Unsupported MaterialX nodedef ND_clamp_color4FA skipped
export float2 clamp(
    varying float2 in_=float2(0.f,0.f),
    uniform float2 low=float2(0.0, 0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float2 high=float2(1.0, 1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx clamp"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::clamp(in_, low, high);
}
export float2 clamp(
    varying float2 in_=float2(0.f,0.f),
    uniform float low=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float high=float(1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx clamp"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::clamp(in_, low, high);
}
export float3 clamp(
    varying float3 in_=float3(0.f,0.f,0.f),
    uniform float3 low=float3(0.0, 0.0, 0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float3 high=float3(1.0, 1.0, 1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx clamp"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::clamp(in_, low, high);
}
export float3 clamp(
    varying float3 in_=float3(0.f,0.f,0.f),
    uniform float low=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float high=float(1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx clamp"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::clamp(in_, low, high);
}
export float4 clamp(
    varying float4 in_=float4(0.f,0.f,0.f,0.f),
    uniform float4 low=float4(0.0, 0.0, 0.0, 0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float4 high=float4(1.0, 1.0, 1.0, 1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx clamp"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::clamp(in_, low, high);
}
export float4 clamp(
    varying float4 in_=float4(0.f,0.f,0.f,0.f),
    uniform float low=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float high=float(1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx clamp"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::clamp(in_, low, high);
}
export float min(
    varying float in1=float(0.f),
    varying float in2=float(0.f))
[[
    anno::display_name("Matx min"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::min(in1, float(in2));
}
// Unsupported MaterialX nodedef ND_min_color2 skipped
// Unsupported MaterialX nodedef ND_min_color2FA skipped
export color3 min(
    varying color3 in1=color3(0.f, 0.f, 0.f),
    varying color3 in2=color3(0.f, 0.f, 0.f))
[[
    anno::display_name("Matx min"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::min(in1, color3(in2));
}
export color3 min(
    varying color3 in1=color3(0.f, 0.f, 0.f),
    varying float in2=float(0.f))
[[
    anno::display_name("Matx min"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::min(in1, color3(in2));
}
// Unsupported MaterialX nodedef ND_min_color4 skipped
// Unsupported MaterialX nodedef ND_min_color4FA skipped
export float2 min(
    varying float2 in1=float2(0.f,0.f),
    varying float2 in2=float2(0.f,0.f))
[[
    anno::display_name("Matx min"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::min(in1, float2(in2));
}
export float2 min(
    varying float2 in1=float2(0.f,0.f),
    varying float in2=float(0.f))
[[
    anno::display_name("Matx min"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::min(in1, float2(in2));
}
export float3 min(
    varying float3 in1=float3(0.f,0.f,0.f),
    varying float3 in2=float3(0.f,0.f,0.f))
[[
    anno::display_name("Matx min"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::min(in1, float3(in2));
}
export float3 min(
    varying float3 in1=float3(0.f,0.f,0.f),
    varying float in2=float(0.f))
[[
    anno::display_name("Matx min"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::min(in1, float3(in2));
}
export float4 min(
    varying float4 in1=float4(0.f,0.f,0.f,0.f),
    varying float4 in2=float4(0.f,0.f,0.f,0.f))
[[
    anno::display_name("Matx min"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::min(in1, float4(in2));
}
export float4 min(
    varying float4 in1=float4(0.f,0.f,0.f,0.f),
    varying float in2=float(0.f))
[[
    anno::display_name("Matx min"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::min(in1, float4(in2));
}
export float max(
    varying float in1=float(0.f),
    varying float in2=float(0.f))
[[
    anno::display_name("Matx max"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::max(in1, float(in2));
}
// Unsupported MaterialX nodedef ND_max_color2 skipped
// Unsupported MaterialX nodedef ND_max_color2FA skipped
export color3 max(
    varying color3 in1=color3(0.f, 0.f, 0.f),
    varying color3 in2=color3(0.f, 0.f, 0.f))
[[
    anno::display_name("Matx max"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::max(in1, color3(in2));
}
export color3 max(
    varying color3 in1=color3(0.f, 0.f, 0.f),
    varying float in2=float(0.f))
[[
    anno::display_name("Matx max"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::max(in1, color3(in2));
}
// Unsupported MaterialX nodedef ND_max_color4 skipped
// Unsupported MaterialX nodedef ND_max_color4FA skipped
export float2 max(
    varying float2 in1=float2(0.f,0.f),
    varying float2 in2=float2(0.f,0.f))
[[
    anno::display_name("Matx max"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::max(in1, float2(in2));
}
export float2 max(
    varying float2 in1=float2(0.f,0.f),
    varying float in2=float(0.f))
[[
    anno::display_name("Matx max"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::max(in1, float2(in2));
}
export float3 max(
    varying float3 in1=float3(0.f,0.f,0.f),
    varying float3 in2=float3(0.f,0.f,0.f))
[[
    anno::display_name("Matx max"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::max(in1, float3(in2));
}
export float3 max(
    varying float3 in1=float3(0.f,0.f,0.f),
    varying float in2=float(0.f))
[[
    anno::display_name("Matx max"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::max(in1, float3(in2));
}
export float4 max(
    varying float4 in1=float4(0.f,0.f,0.f,0.f),
    varying float4 in2=float4(0.f,0.f,0.f,0.f))
[[
    anno::display_name("Matx max"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::max(in1, float4(in2));
}
export float4 max(
    varying float4 in1=float4(0.f,0.f,0.f,0.f),
    varying float in2=float(0.f))
[[
    anno::display_name("Matx max"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::max(in1, float4(in2));
}
export float2 normalize(
    varying float2 in_=float2(0.f,0.f))
[[
    anno::display_name("Matx normalize"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::normalize(in_);
}
export float3 normalize(
    varying float3 in_=float3(0.f,0.f,0.f))
[[
    anno::display_name("Matx normalize"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::normalize(in_);
}
export float4 normalize(
    varying float4 in_=float4(0.f,0.f,0.f,0.f))
[[
    anno::display_name("Matx normalize"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::normalize(in_);
}
export float magnitude(
    varying float2 in_=float2(0.f,0.f))
[[
    anno::display_name("Matx magnitude"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::length(in_);
}
export float magnitude(
    varying float3 in_=float3(0.f,0.f,0.f))
[[
    anno::display_name("Matx magnitude"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::length(in_);
}
export float magnitude(
    varying float4 in_=float4(0.f,0.f,0.f,0.f))
[[
    anno::display_name("Matx magnitude"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::length(in_);
}
export float dotproduct(
    varying float2 in1=float2(0.f,0.f),
    varying float2 in2=float2(0.f,0.f))
[[
    anno::display_name("Matx dotproduct"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::dot(in1, in2);
}
export float dotproduct(
    varying float3 in1=float3(0.f,0.f,0.f),
    varying float3 in2=float3(0.f,0.f,0.f))
[[
    anno::display_name("Matx dotproduct"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::dot(in1, in2);
}
export float dotproduct(
    varying float4 in1=float4(0.f,0.f,0.f,0.f),
    varying float4 in2=float4(0.f,0.f,0.f,0.f))
[[
    anno::display_name("Matx dotproduct"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::dot(in1, in2);
}
export float3 crossproduct(
    varying float3 in1=float3(0.f,0.f,0.f),
    varying float3 in2=float3(0.f,0.f,0.f))
[[
    anno::display_name("Matx crossproduct"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::cross(in1, in2);
}
// Error: Ignoring incompatible vector sizes
/*export float2 transformpoint(
    varying float2 in_=float2(0.f,0.f),
    varying float3x3 mat=float3x3(1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0))
[[
    anno::display_name("Matx transformpoint"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return in_*mat;
}
*/
export float3 transformpoint(
    varying float3 in_=float3(0.f,0.f,0.f),
    uniform string fromspace=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string tospace=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx transformpoint"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    state::coordinate_space fromMdlSpace = mtlx::utilities::getSpaceByString(fromspace);
    state::coordinate_space toMdlSpace = mtlx::utilities::getSpaceByString(tospace);
    return mtlx::utilities::to_float3(state::transform_point(fromMdlSpace, toMdlSpace, mtlx::utilities::to_float3(in_)));
}
export float3 transformpoint(
    varying float3 in_=float3(0.f,0.f,0.f),
    varying float3x3 mat=float3x3(1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0))
[[
    anno::display_name("Matx transformpoint"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return in_*mat;
}
// Error: Ignoring incompatible vector sizes
/*export float3 transformpoint(
    varying float3 in_=float3(0.f,0.f,0.f),
    varying float4x4 mat=float4x4(1.0,0.0,0.0,0.0, 0.0,1.0,0.0,0.0, 0.0,0.0,1.0,0.0, 0.0,0.0,0.0,1.0))
[[
    anno::display_name("Matx transformpoint"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return in_*mat;
}
*/
// Error: Ignoring incompatible vector sizes
/*export float2 transformvector(
    varying float2 in_=float2(0.f,0.f),
    varying float3x3 mat=float3x3(1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0))
[[
    anno::display_name("Matx transformvector"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return in_*mat;
}
*/
export float3 transformvector(
    varying float3 in_=float3(0.f,0.f,0.f),
    uniform string fromspace=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string tospace=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx transformvector"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    state::coordinate_space fromMdlSpace = mtlx::utilities::getSpaceByString(fromspace);
    state::coordinate_space toMdlSpace = mtlx::utilities::getSpaceByString(tospace);
    return mtlx::utilities::to_float3(state::transform_vector(fromMdlSpace, toMdlSpace, mtlx::utilities::to_float3(in_)));
}
export float3 transformvector(
    varying float3 in_=float3(0.f,0.f,0.f),
    varying float3x3 mat=float3x3(1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0))
[[
    anno::display_name("Matx transformvector"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return in_*mat;
}
// Error: Ignoring incompatible vector sizes
/*export float3 transformvector(
    varying float3 in_=float3(0.f,0.f,0.f),
    varying float4x4 mat=float4x4(1.0,0.0,0.0,0.0, 0.0,1.0,0.0,0.0, 0.0,0.0,1.0,0.0, 0.0,0.0,0.0,1.0))
[[
    anno::display_name("Matx transformvector"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return in_*mat;
}
*/
export float4 transformvector(
    varying float4 in_=float4(0.f,0.f,0.f,0.f),
    varying float4x4 mat=float4x4(1.0,0.0,0.0,0.0, 0.0,1.0,0.0,0.0, 0.0,0.0,1.0,0.0, 0.0,0.0,0.0,1.0))
[[
    anno::display_name("Matx transformvector"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return in_*mat;
}
export float3 transformnormal(
    varying float3 in_=float3(0.f,0.f,0.f),
    uniform string fromspace=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string tospace=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx transformnormal"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    state::coordinate_space fromMdlSpace = mtlx::utilities::getSpaceByString(fromspace);
    state::coordinate_space toMdlSpace = mtlx::utilities::getSpaceByString(tospace);
    return mtlx::utilities::to_float3(state::transform_normal(fromMdlSpace, toMdlSpace, mtlx::utilities::to_float3(in_)));
}
export float3 transformnormal(
    varying float3 in_=float3(0.f,0.f,0.f),
    varying float3x3 mat=float3x3(1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0))
[[
    anno::display_name("Matx transformnormal"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return in_*mat;
}
// Error: Ignoring incompatible vector sizes
/*export float3 transformnormal(
    varying float3 in_=float3(0.f,0.f,0.f),
    varying float4x4 mat=float4x4(1.0,0.0,0.0,0.0, 0.0,1.0,0.0,0.0, 0.0,0.0,1.0,0.0, 0.0,0.0,0.0,1.0))
[[
    anno::display_name("Matx transformnormal"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return in_*mat;
}
*/
export float3x3 transpose(
    varying float3x3 in_=float3x3(0.f))
[[
    anno::display_name("Matx transpose"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::transpose(in_);
}
export float4x4 transpose(
    varying float4x4 in_=float4x4(0.f))
[[
    anno::display_name("Matx transpose"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::transpose(in_);
}
export float determinant(
    varying float3x3 in_=float3x3(0.f))
[[
    anno::display_name("Matx determinant"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return mtlx::utilities::determinant(in_);
}
export float determinant(
    varying float4x4 in_=float4x4(0.f))
[[
    anno::display_name("Matx determinant"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return mtlx::utilities::determinant(in_);
}
export float2 rotate(
    varying float2 in_=float2(0.f,0.f),
    varying float amount=float(0.0))
[[
    anno::display_name("Matx rotate"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return mtlx::utilities::rotate_float2(in_, amount);
}
export float3 rotate(
    varying float3 in_=float3(0.f,0.f,0.f),
    varying float amount=float(0.0),
    uniform float3 axis=float3(0.f,0.f,0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx rotate"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return mtlx::utilities::rotate_float3(in_, amount, axis);
}
export float2 place2d(
    varying float2 texcoord=float2(0.f,0.f),
    varying float2 scale=float2(1.0,1.0),
    varying float rotate_=float(0.0),
    varying float2 offset=float2(0.0,0.0),
    uniform float2 pivot=float2(0.0,0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx place2d"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    float2 v_0 = subtract(texcoord, pivot);
    float2 v_1 = divide(v_0, scale);
    float2 v_2 = rotate(v_1, rotate_);
    float2 v_3 = subtract(v_2, offset);
    float2 v_4 = add(v_3, pivot);
    return v_4;
}
// Unsupported MaterialX nodedef ND_arrayappend_integer_integerarray skipped
// Unsupported MaterialX nodedef ND_arrayappend_integerarray_integerarray skipped
// Unsupported MaterialX nodedef ND_arrayappend_float_floatarray skipped
// Unsupported MaterialX nodedef ND_arrayappend_floatarray_floatarray skipped
// Unsupported MaterialX nodedef ND_arrayappend_color2_color2array skipped
// Unsupported MaterialX nodedef ND_arrayappend_color2array_color2array skipped
// Unsupported MaterialX nodedef ND_arrayappend_color3_color3array skipped
// Unsupported MaterialX nodedef ND_arrayappend_color3array_color3array skipped
// Unsupported MaterialX nodedef ND_arrayappend_color4_color4array skipped
// Unsupported MaterialX nodedef ND_arrayappend_color4array_color4array skipped
// Unsupported MaterialX nodedef ND_arrayappend_vector2_vector2array skipped
// Unsupported MaterialX nodedef ND_arrayappend_vector2array_vector2array skipped
// Unsupported MaterialX nodedef ND_arrayappend_vector3_vector3array skipped
// Unsupported MaterialX nodedef ND_arrayappend_vector3array_vector3array skipped
// Unsupported MaterialX nodedef ND_arrayappend_vector4_vector4array skipped
// Unsupported MaterialX nodedef ND_arrayappend_vector4array_vector4array skipped
// Unsupported MaterialX nodedef ND_arrayappend_string_stringarray skipped
// Unsupported MaterialX nodedef ND_arrayappend_stringarray_stringarray skipped
export float remap(
    varying float in_=float(0.f),
    uniform float inlow=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float inhigh=float(1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float outlow=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float outhigh=float(1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx remap"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return outlow + (in_ - inlow) * (outhigh - outlow) / (inhigh - inlow);
}
// Unsupported MaterialX nodedef ND_remap_color2 skipped
// Unsupported MaterialX nodedef ND_remap_color2FA skipped
export color3 remap(
    varying color3 in_=color3(0.f, 0.f, 0.f),
    uniform color3 inlow=color3(0.0, 0.0, 0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform color3 inhigh=color3(1.0, 1.0, 1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform color3 outlow=color3(0.0, 0.0, 0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform color3 outhigh=color3(1.0, 1.0, 1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx remap"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return outlow + (in_ - inlow) * (outhigh - outlow) / (inhigh - inlow);
}
export color3 remap(
    varying color3 in_=color3(0.f, 0.f, 0.f),
    uniform float inlow=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float inhigh=float(1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float outlow=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float outhigh=float(1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx remap"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return outlow + (in_ - inlow) * (outhigh - outlow) / (inhigh - inlow);
}
// Unsupported MaterialX nodedef ND_remap_color4 skipped
// Unsupported MaterialX nodedef ND_remap_color4FA skipped
export float2 remap(
    varying float2 in_=float2(0.f,0.f),
    uniform float2 inlow=float2(0.0, 0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float2 inhigh=float2(1.0, 1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float2 outlow=float2(0.0, 0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float2 outhigh=float2(1.0, 1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx remap"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return outlow + (in_ - inlow) * (outhigh - outlow) / (inhigh - inlow);
}
export float2 remap(
    varying float2 in_=float2(0.f,0.f),
    uniform float inlow=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float inhigh=float(1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float outlow=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float outhigh=float(1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx remap"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return outlow + (in_ - inlow) * (outhigh - outlow) / (inhigh - inlow);
}
export float3 remap(
    varying float3 in_=float3(0.f,0.f,0.f),
    uniform float3 inlow=float3(0.0, 0.0, 0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float3 inhigh=float3(1.0, 1.0, 1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float3 outlow=float3(0.0, 0.0, 0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float3 outhigh=float3(1.0, 1.0, 1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx remap"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return outlow + (in_ - inlow) * (outhigh - outlow) / (inhigh - inlow);
}
export float3 remap(
    varying float3 in_=float3(0.f,0.f,0.f),
    uniform float inlow=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float inhigh=float(1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float outlow=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float outhigh=float(1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx remap"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return outlow + (in_ - inlow) * (outhigh - outlow) / (inhigh - inlow);
}
export float4 remap(
    varying float4 in_=float4(0.f,0.f,0.f,0.f),
    uniform float4 inlow=float4(0.0, 0.0, 0.0, 0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float4 inhigh=float4(1.0, 1.0, 1.0, 1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float4 outlow=float4(0.0, 0.0, 0.0, 0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float4 outhigh=float4(1.0, 1.0, 1.0, 1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx remap"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return outlow + (in_ - inlow) * (outhigh - outlow) / (inhigh - inlow);
}
export float4 remap(
    varying float4 in_=float4(0.f,0.f,0.f,0.f),
    uniform float inlow=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float inhigh=float(1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float outlow=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float outhigh=float(1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx remap"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return outlow + (in_ - inlow) * (outhigh - outlow) / (inhigh - inlow);
}
export float smoothstep(
    varying float in_=float(0.f),
    uniform float low=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float high=float(1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx smoothstep"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::smoothstep(float(low), float(high), in_);
}
// Unsupported MaterialX nodedef ND_smoothstep_color2 skipped
// Unsupported MaterialX nodedef ND_smoothstep_color2FA skipped
export color3 smoothstep(
    varying color3 in_=color3(0.f, 0.f, 0.f),
    uniform color3 low=color3(0.0, 0.0, 0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform color3 high=color3(1.0, 1.0, 1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx smoothstep"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return color3(math::smoothstep(float3(low), float3(high), float3(in_)));
}
export color3 smoothstep(
    varying color3 in_=color3(0.f, 0.f, 0.f),
    uniform float low=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float high=float(1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx smoothstep"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return color3(math::smoothstep(float3(low), float3(high), float3(in_)));
}
// Unsupported MaterialX nodedef ND_smoothstep_color4 skipped
// Unsupported MaterialX nodedef ND_smoothstep_color4FA skipped
export float2 smoothstep(
    varying float2 in_=float2(0.f,0.f),
    uniform float2 low=float2(0.0, 0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float2 high=float2(1.0, 1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx smoothstep"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::smoothstep(float2(low), float2(high), in_);
}
export float2 smoothstep(
    varying float2 in_=float2(0.f,0.f),
    uniform float low=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float high=float(1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx smoothstep"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::smoothstep(float2(low), float2(high), in_);
}
export float3 smoothstep(
    varying float3 in_=float3(0.f,0.f,0.f),
    uniform float3 low=float3(0.0, 0.0, 0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float3 high=float3(1.0, 1.0, 1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx smoothstep"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::smoothstep(float3(low), float3(high), in_);
}
export float3 smoothstep(
    varying float3 in_=float3(0.f,0.f,0.f),
    uniform float low=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float high=float(1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx smoothstep"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::smoothstep(float3(low), float3(high), in_);
}
export float4 smoothstep(
    varying float4 in_=float4(0.f,0.f,0.f,0.f),
    uniform float4 low=float4(0.0, 0.0, 0.0, 0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float4 high=float4(1.0, 1.0, 1.0, 1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx smoothstep"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::smoothstep(float4(low), float4(high), in_);
}
export float4 smoothstep(
    varying float4 in_=float4(0.f,0.f,0.f,0.f),
    uniform float low=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float high=float(1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx smoothstep"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::smoothstep(float4(low), float4(high), in_);
}
// Unsupported MaterialX nodedef ND_curveadjust_float skipped
// Unsupported MaterialX nodedef ND_curveadjust_color2 skipped
// Unsupported MaterialX nodedef ND_curveadjust_color3 skipped
// Unsupported MaterialX nodedef ND_curveadjust_color4 skipped
// Unsupported MaterialX nodedef ND_curveadjust_vector2 skipped
// Unsupported MaterialX nodedef ND_curveadjust_vector3 skipped
// Unsupported MaterialX nodedef ND_curveadjust_vector4 skipped
export color3 luminance(
    varying color3 in_=color3(0.f, 0.f, 0.f),
    uniform color3 lumacoeffs=color3(0.272287, 0.6740818, 0.0536895)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx luminance"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return color3(math::dot(float3(in_), float3(lumacoeffs)));
}
// Unsupported MaterialX nodedef ND_luminance_color4 skipped
export color3 rgbtohsv(
    varying color3 in_=color3(0.f, 0.f, 0.f))
[[
    anno::display_name("Matx rgbtohsv"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return mtlx::utilities::rgb2hsv(in_);
}
// Unsupported MaterialX nodedef ND_rgbtohsv_color4 skipped
export color3 hsvtorgb(
    varying color3 in_=color3(0.f, 0.f, 0.f))
[[
    anno::display_name("Matx hsvtorgb"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return mtlx::utilities::hsv2rgb(in_);
}
// Unsupported MaterialX nodedef ND_hsvtorgb_color4 skipped
export float contrast(
    varying float in_=float(0.f),
    uniform float amount=float(1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float pivot=float(0.5)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx contrast"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return (in_ - pivot)*float(amount) + pivot;
}
// Unsupported MaterialX nodedef ND_contrast_color2 skipped
// Unsupported MaterialX nodedef ND_contrast_color2FA skipped
export color3 contrast(
    varying color3 in_=color3(0.f, 0.f, 0.f),
    uniform color3 amount=color3(0.f, 0.f, 0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform color3 pivot=color3(0.5, 0.5, 0.5)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx contrast"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return (in_ - pivot)*color3(amount) + pivot;
}
export color3 contrast(
    varying color3 in_=color3(0.f, 0.f, 0.f),
    uniform float amount=float(1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float pivot=float(0.5)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx contrast"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return (in_ - pivot)*color3(amount) + pivot;
}
// Unsupported MaterialX nodedef ND_contrast_color4 skipped
// Unsupported MaterialX nodedef ND_contrast_color4FA skipped
export float2 contrast(
    varying float2 in_=float2(0.f,0.f),
    uniform float2 amount=float2(0.f,0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float2 pivot=float2(0.5, 0.5)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx contrast"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return (in_ - pivot)*float2(amount) + pivot;
}
export float2 contrast(
    varying float2 in_=float2(0.f,0.f),
    uniform float amount=float(1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float pivot=float(0.5)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx contrast"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return (in_ - pivot)*float2(amount) + pivot;
}
export float3 contrast(
    varying float3 in_=float3(0.f,0.f,0.f),
    uniform float3 amount=float3(0.f,0.f,0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float3 pivot=float3(0.5, 0.5, 0.5)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx contrast"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return (in_ - pivot)*float3(amount) + pivot;
}
export float3 contrast(
    varying float3 in_=float3(0.f,0.f,0.f),
    uniform float amount=float(1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float pivot=float(0.5)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx contrast"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return (in_ - pivot)*float3(amount) + pivot;
}
export float4 contrast(
    varying float4 in_=float4(0.f,0.f,0.f,0.f),
    uniform float4 amount=float4(0.f,0.f,0.f,0.f)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float4 pivot=float4(0.5, 0.5, 0.5, 0.5)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx contrast"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return (in_ - pivot)*float4(amount) + pivot;
}
export float4 contrast(
    varying float4 in_=float4(0.f,0.f,0.f,0.f),
    uniform float amount=float(1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float pivot=float(0.5)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx contrast"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return (in_ - pivot)*float4(amount) + pivot;
}
export float range(
    varying float in_=float(0.f),
    uniform float inlow=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float inhigh=float(1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float gamma=float(1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float outlow=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float outhigh=float(1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform bool doclamp=bool(false)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx range"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    float retval = outlow + (in_ - inlow)*(outhigh - outlow)/(inhigh - inlow);
    retval = math::pow(retval, 1.0/gamma);
    if (doclamp) 
        retval = math::clamp(retval, outlow, outhigh);
    return retval;
}
// Unsupported MaterialX nodedef ND_range_color2 skipped
// Unsupported MaterialX nodedef ND_range_color2FA skipped
export color3 range(
    varying color3 in_=color3(0.f, 0.f, 0.f),
    uniform color3 inlow=color3(0.0, 0.0, 0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform color3 inhigh=color3(1.0, 1.0, 1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform color3 gamma=color3(1.0, 1.0, 1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform color3 outlow=color3(0.0, 0.0, 0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform color3 outhigh=color3(1.0, 1.0, 1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform bool doclamp=bool(false)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx range"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    color3 retval = outlow + (in_ - inlow)*(outhigh - outlow)/(inhigh - inlow);
    retval = math::pow(retval, 1.0/gamma);
    if (doclamp) 
        retval = math::clamp(retval, outlow, outhigh);
    return retval;
}
export color3 range(
    varying color3 in_=color3(0.f, 0.f, 0.f),
    uniform float inlow=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float inhigh=float(1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float gamma=float(1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float outlow=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float outhigh=float(1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform bool doclamp=bool(false)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx range"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    color3 retval = outlow + (in_ - inlow)*(outhigh - outlow)/(inhigh - inlow);
    retval = math::pow(retval, 1.0/gamma);
    if (doclamp) 
        retval = math::clamp(retval, outlow, outhigh);
    return retval;
}
// Unsupported MaterialX nodedef ND_range_color4 skipped
// Unsupported MaterialX nodedef ND_range_color4FA skipped
export float2 range(
    varying float2 in_=float2(0.f,0.f),
    uniform float2 inlow=float2(0.0, 0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float2 inhigh=float2(1.0, 1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float2 gamma=float2(1.0, 1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float2 outlow=float2(0.0, 0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float2 outhigh=float2(1.0, 1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform bool doclamp=bool(false)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx range"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    float2 retval = outlow + (in_ - inlow)*(outhigh - outlow)/(inhigh - inlow);
    retval = math::pow(retval, 1.0/gamma);
    if (doclamp) 
        retval = math::clamp(retval, outlow, outhigh);
    return retval;
}
export float2 range(
    varying float2 in_=float2(0.f,0.f),
    uniform float inlow=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float inhigh=float(1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float gamma=float(1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float outlow=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float outhigh=float(1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform bool doclamp=bool(false)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx range"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    float2 retval = outlow + (in_ - inlow)*(outhigh - outlow)/(inhigh - inlow);
    retval = math::pow(retval, 1.0/gamma);
    if (doclamp) 
        retval = math::clamp(retval, outlow, outhigh);
    return retval;
}
export float3 range(
    varying float3 in_=float3(0.f,0.f,0.f),
    uniform float3 inlow=float3(0.0, 0.0, 0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float3 inhigh=float3(1.0, 1.0, 1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float3 gamma=float3(1.0, 1.0, 1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float3 outlow=float3(0.0, 0.0, 0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float3 outhigh=float3(1.0, 1.0, 1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform bool doclamp=bool(false)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx range"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    float3 retval = outlow + (in_ - inlow)*(outhigh - outlow)/(inhigh - inlow);
    retval = math::pow(retval, 1.0/gamma);
    if (doclamp) 
        retval = math::clamp(retval, outlow, outhigh);
    return retval;
}
export float3 range(
    varying float3 in_=float3(0.f,0.f,0.f),
    uniform float inlow=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float inhigh=float(1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float gamma=float(1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float outlow=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float outhigh=float(1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform bool doclamp=bool(false)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx range"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    float3 retval = outlow + (in_ - inlow)*(outhigh - outlow)/(inhigh - inlow);
    retval = math::pow(retval, 1.0/gamma);
    if (doclamp) 
        retval = math::clamp(retval, outlow, outhigh);
    return retval;
}
export float4 range(
    varying float4 in_=float4(0.f,0.f,0.f,0.f),
    uniform float4 inlow=float4(0.0, 0.0, 0.0, 0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float4 inhigh=float4(1.0, 1.0, 1.0, 1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float4 gamma=float4(1.0, 1.0, 1.0, 1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float4 outlow=float4(0.0, 0.0, 0.0, 0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float4 outhigh=float4(1.0, 1.0, 1.0, 1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform bool doclamp=bool(false)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx range"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    float4 retval = outlow + (in_ - inlow)*(outhigh - outlow)/(inhigh - inlow);
    retval = math::pow(retval, 1.0/gamma);
    if (doclamp) 
        retval = math::clamp(retval, outlow, outhigh);
    return retval;
}
export float4 range(
    varying float4 in_=float4(0.f,0.f,0.f,0.f),
    uniform float inlow=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float inhigh=float(1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float gamma=float(1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float outlow=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform float outhigh=float(1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform bool doclamp=bool(false)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx range"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    float4 retval = outlow + (in_ - inlow)*(outhigh - outlow)/(inhigh - inlow);
    retval = math::pow(retval, 1.0/gamma);
    if (doclamp) 
        retval = math::clamp(retval, outlow, outhigh);
    return retval;
}
export color3 hsvadjust(
    varying color3 in_=color3(0.f, 0.f, 0.f),
    uniform float3 amount=float3(0.0, 1.0, 1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx hsvadjust"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    float3 hsvval = float3(mtlx::utilities::rgb2hsv(in_));
    hsvval = float3(hsvval.x+amount.x, hsvval.y*amount.y, hsvval.z*amount.z);
    return mtlx::utilities::hsv2rgb(color3(hsvval));
}
// Unsupported MaterialX nodedef ND_hsvadjust_color4 skipped
export color3 saturate(
    varying color3 in_=color3(0.f, 0.f, 0.f),
    uniform float amount=float(1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform color3 lumacoeffs=color3(0.272287, 0.6740818, 0.0536895)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx saturate"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::lerp(
       color3(math::dot(float3(in_), float3(lumacoeffs))), in_, amount);
}
// Unsupported MaterialX nodedef ND_saturate_color4 skipped
// Unsupported MaterialX nodedef ND_premult_color2 skipped
export color3 premult(
    varying color3 in_=color3(0.f, 0.f, 0.f),
    varying float alpha=float(0.f))
[[
    anno::display_name("Matx premult"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return in_*alpha;
}
// Unsupported MaterialX nodedef ND_premult_color4 skipped
// Unsupported MaterialX nodedef ND_unpremult_color2 skipped
export color3 unpremult(
    varying color3 in_=color3(0.f, 0.f, 0.f),
    varying float alpha=float(0.f))
[[
    anno::display_name("Matx unpremult"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return in_/alpha;
}
// Unsupported MaterialX nodedef ND_unpremult_color4 skipped
export float plus(
    varying float fg=float(0.f),
    varying float bg=float(0.f),
    varying float mix=float(0.f))
[[
    anno::display_name("Matx plus"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::lerp(bg, bg+fg, mix);
}
// Unsupported MaterialX nodedef ND_plus_color2 skipped
export color3 plus(
    varying color3 fg=color3(0.f, 0.f, 0.f),
    varying color3 bg=color3(0.f, 0.f, 0.f),
    varying float mix=float(0.f))
[[
    anno::display_name("Matx plus"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::lerp(bg, bg+fg, mix);
}
// Unsupported MaterialX nodedef ND_plus_color4 skipped
export float minus(
    varying float fg=float(0.f),
    varying float bg=float(0.f),
    varying float mix=float(0.f))
[[
    anno::display_name("Matx minus"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::lerp(bg, bg-fg, mix);
}
// Unsupported MaterialX nodedef ND_minus_color2 skipped
export color3 minus(
    varying color3 fg=color3(0.f, 0.f, 0.f),
    varying color3 bg=color3(0.f, 0.f, 0.f),
    varying float mix=float(0.f))
[[
    anno::display_name("Matx minus"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::lerp(bg, bg-fg, mix);
}
// Unsupported MaterialX nodedef ND_minus_color4 skipped
export float difference(
    varying float fg=float(0.f),
    varying float bg=float(0.f),
    varying float mix=float(0.f))
[[
    anno::display_name("Matx difference"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::lerp(bg, math::abs(bg-fg), mix);
}
// Unsupported MaterialX nodedef ND_difference_color2 skipped
export color3 difference(
    varying color3 fg=color3(0.f, 0.f, 0.f),
    varying color3 bg=color3(0.f, 0.f, 0.f),
    varying float mix=float(0.f))
[[
    anno::display_name("Matx difference"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::lerp(bg, math::abs(bg-fg), mix);
}
// Unsupported MaterialX nodedef ND_difference_color4 skipped
export float burn(
    varying float fg=float(0.f),
    varying float bg=float(0.f),
    varying float mix=float(0.f))
[[
    anno::display_name("Matx burn"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::lerp(bg, float(1.0)-(float(1.0)-bg)/fg, mix);
}
// Unsupported MaterialX nodedef ND_burn_color2 skipped
export color3 burn(
    varying color3 fg=color3(0.f, 0.f, 0.f),
    varying color3 bg=color3(0.f, 0.f, 0.f),
    varying float mix=float(0.f))
[[
    anno::display_name("Matx burn"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::lerp(bg, color3(1.0)-(color3(1.0)-bg)/fg, mix);
}
// Unsupported MaterialX nodedef ND_burn_color4 skipped
export float dodge(
    varying float fg=float(0.f),
    varying float bg=float(0.f),
    varying float mix=float(0.f))
[[
    anno::display_name("Matx dodge"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::lerp(bg, bg/(float(1.0)-fg), mix);
}
// Unsupported MaterialX nodedef ND_dodge_color2 skipped
export color3 dodge(
    varying color3 fg=color3(0.f, 0.f, 0.f),
    varying color3 bg=color3(0.f, 0.f, 0.f),
    varying float mix=float(0.f))
[[
    anno::display_name("Matx dodge"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::lerp(bg, bg/(color3(1.0)-fg), mix);
}
// Unsupported MaterialX nodedef ND_dodge_color4 skipped
export float screen(
    varying float fg=float(0.f),
    varying float bg=float(0.f),
    varying float mix=float(0.f))
[[
    anno::display_name("Matx screen"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::lerp(bg, bg+fg-bg*fg, mix);
}
// Unsupported MaterialX nodedef ND_screen_color2 skipped
export color3 screen(
    varying color3 fg=color3(0.f, 0.f, 0.f),
    varying color3 bg=color3(0.f, 0.f, 0.f),
    varying float mix=float(0.f))
[[
    anno::display_name("Matx screen"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::lerp(bg, bg+fg-bg*fg, mix);
}
// Unsupported MaterialX nodedef ND_screen_color4 skipped
export float overlay(
    varying float fg=float(0.f),
    varying float bg=float(0.f),
    varying float mix=float(0.f))
[[
    anno::display_name("Matx overlay"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    float upper, lower, mask, overlayval;
    float fg_ = float(fg);
    float bg_ = float(bg);
    upper = 2.0*bg_*fg_;
    lower = bg_+fg_-bg_*fg_;
    mask = math::step(float(.5), fg_);
    overlayval = math::lerp(lower, upper, mask);
    return float(math::lerp(bg, overlayval, mix));
}
// Unsupported MaterialX nodedef ND_overlay_color2 skipped
export color3 overlay(
    varying color3 fg=color3(0.f, 0.f, 0.f),
    varying color3 bg=color3(0.f, 0.f, 0.f),
    varying float mix=float(0.f))
[[
    anno::display_name("Matx overlay"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    float3 upper, lower, mask, overlayval;
    float3 fg_ = float3(fg);
    float3 bg_ = float3(bg);
    upper = 2.0*bg_*fg_;
    lower = bg_+fg_-bg_*fg_;
    mask = math::step(float3(.5), fg_);
    overlayval = math::lerp(lower, upper, mask);
    return color3(math::lerp(bg, overlayval, mix));
}
// Unsupported MaterialX nodedef ND_overlay_color4 skipped
// Unsupported MaterialX nodedef ND_disjointover_color2 skipped
// Unsupported MaterialX nodedef ND_disjointover_color4 skipped
// Unsupported MaterialX nodedef ND_in_color2 skipped
// Unsupported MaterialX nodedef ND_in_color4 skipped
// Unsupported MaterialX nodedef ND_mask_color2 skipped
// Unsupported MaterialX nodedef ND_mask_color4 skipped
// Unsupported MaterialX nodedef ND_matte_color2 skipped
// Unsupported MaterialX nodedef ND_matte_color4 skipped
// Unsupported MaterialX nodedef ND_out_color2 skipped
// Unsupported MaterialX nodedef ND_out_color4 skipped
// Unsupported MaterialX nodedef ND_over_color2 skipped
// Unsupported MaterialX nodedef ND_over_color4 skipped
export float inside(
    varying float in_=float(0.f),
    varying float mask=float(0.f))
[[
    anno::display_name("Matx inside"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return in_*mask;
}
// Unsupported MaterialX nodedef ND_inside_color2 skipped
export color3 inside(
    varying color3 in_=color3(0.f, 0.f, 0.f),
    varying float mask=float(0.f))
[[
    anno::display_name("Matx inside"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return in_*mask;
}
// Unsupported MaterialX nodedef ND_inside_color4 skipped
export float outside(
    varying float in_=float(0.f),
    varying float mask=float(0.f))
[[
    anno::display_name("Matx outside"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return in_*(1.0-mask);
}
// Unsupported MaterialX nodedef ND_outside_color2 skipped
export color3 outside(
    varying color3 in_=color3(0.f, 0.f, 0.f),
    varying float mask=float(0.f))
[[
    anno::display_name("Matx outside"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return in_*(1.0-mask);
}
// Unsupported MaterialX nodedef ND_outside_color4 skipped
export float mix(
    varying float fg=float(0.f),
    varying float bg=float(0.f),
    varying float mix=float(0.f))
[[
    anno::display_name("Matx mix"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::lerp(bg, fg, mix);
}
// Unsupported MaterialX nodedef ND_mix_color2 skipped
export color3 mix(
    varying color3 fg=color3(0.f, 0.f, 0.f),
    varying color3 bg=color3(0.f, 0.f, 0.f),
    varying float mix=float(0.f))
[[
    anno::display_name("Matx mix"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::lerp(bg, fg, mix);
}
// Unsupported MaterialX nodedef ND_mix_color4 skipped
export float2 mix(
    varying float2 fg=float2(0.f,0.f),
    varying float2 bg=float2(0.f,0.f),
    varying float mix=float(0.f))
[[
    anno::display_name("Matx mix"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::lerp(bg, fg, mix);
}
export float3 mix(
    varying float3 fg=float3(0.f,0.f,0.f),
    varying float3 bg=float3(0.f,0.f,0.f),
    varying float mix=float(0.f))
[[
    anno::display_name("Matx mix"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::lerp(bg, fg, mix);
}
export float4 mix(
    varying float4 fg=float4(0.f,0.f,0.f,0.f),
    varying float4 bg=float4(0.f,0.f,0.f,0.f),
    varying float mix=float(0.f))
[[
    anno::display_name("Matx mix"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return math::lerp(bg, fg, mix);
}
// Error: material type nodes are dummy implemented
/*export material mix(
    varying material fg=material(),
    varying material bg=material(),
    varying float mix=float(0.f))=mtlx::utilities::dummyMaterial();
*/
// Unsupported MaterialX nodedef ND_mix_displacementshader skipped
// Unsupported MaterialX nodedef ND_mix_volumeshader skipped
export float compare(
    varying float intest=float(0.f),
    varying float in1=float(0.f),
    varying float in2=float(0.f),
    uniform float cutoff=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx compare"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    float mask = math::step(cutoff, intest);
    return math::lerp(in1, in2, mask);
}
// Unsupported MaterialX nodedef ND_compare_color2 skipped
export color3 compare(
    varying float intest=float(0.f),
    varying color3 in1=color3(0.f, 0.f, 0.f),
    varying color3 in2=color3(0.f, 0.f, 0.f),
    uniform float cutoff=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx compare"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    float mask = math::step(cutoff, intest);
    return math::lerp(in1, in2, mask);
}
// Unsupported MaterialX nodedef ND_compare_color4 skipped
export float2 compare(
    varying float intest=float(0.f),
    varying float2 in1=float2(0.f,0.f),
    varying float2 in2=float2(0.f,0.f),
    uniform float cutoff=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx compare"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    float mask = math::step(cutoff, intest);
    return math::lerp(in1, in2, mask);
}
export float3 compare(
    varying float intest=float(0.f),
    varying float3 in1=float3(0.f,0.f,0.f),
    varying float3 in2=float3(0.f,0.f,0.f),
    uniform float cutoff=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx compare"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    float mask = math::step(cutoff, intest);
    return math::lerp(in1, in2, mask);
}
export float4 compare(
    varying float intest=float(0.f),
    varying float4 in1=float4(0.f,0.f,0.f,0.f),
    varying float4 in2=float4(0.f,0.f,0.f,0.f),
    uniform float cutoff=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx compare"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    float mask = math::step(cutoff, intest);
    return math::lerp(in1, in2, mask);
}
// Unsupported MaterialX nodedef ND_switch_float skipped
// Unsupported MaterialX nodedef ND_switch_color2 skipped
// Unsupported MaterialX nodedef ND_switch_color3 skipped
// Unsupported MaterialX nodedef ND_switch_color4 skipped
// Unsupported MaterialX nodedef ND_switch_vector2 skipped
// Unsupported MaterialX nodedef ND_switch_vector3 skipped
// Unsupported MaterialX nodedef ND_switch_vector4 skipped
export float switch_(
    varying float in1=float(0.0),
    varying float in2=float(0.0),
    varying float in3=float(0.0),
    varying float in4=float(0.0),
    varying float in5=float(0.0),
    uniform int which=int(0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx switch"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    int which_ = which;
    if (which_ == 1) return in2;
    if (which_ == 2) return in3;
    if (which_ == 3) return in4;
    if (which_ >= 4) return in5;
    return in1;
}
// Unsupported MaterialX nodedef ND_switch_color2I skipped
export color3 switch_(
    varying color3 in1=color3(0.0, 0.0, 0.0),
    varying color3 in2=color3(0.0, 0.0, 0.0),
    varying color3 in3=color3(0.0, 0.0, 0.0),
    varying color3 in4=color3(0.0, 0.0, 0.0),
    varying color3 in5=color3(0.0, 0.0, 0.0),
    uniform int which=int(0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx switch"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    int which_ = which;
    if (which_ == 1) return in2;
    if (which_ == 2) return in3;
    if (which_ == 3) return in4;
    if (which_ >= 4) return in5;
    return in1;
}
// Unsupported MaterialX nodedef ND_switch_color4I skipped
export float2 switch_(
    varying float2 in1=float2(0.0, 0.0),
    varying float2 in2=float2(0.0, 0.0),
    varying float2 in3=float2(0.0, 0.0),
    varying float2 in4=float2(0.0, 0.0),
    varying float2 in5=float2(0.0, 0.0),
    uniform int which=int(0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx switch"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    int which_ = which;
    if (which_ == 1) return in2;
    if (which_ == 2) return in3;
    if (which_ == 3) return in4;
    if (which_ >= 4) return in5;
    return in1;
}
export float3 switch_(
    varying float3 in1=float3(0.0, 0.0, 0.0),
    varying float3 in2=float3(0.0, 0.0, 0.0),
    varying float3 in3=float3(0.0, 0.0, 0.0),
    varying float3 in4=float3(0.0, 0.0, 0.0),
    varying float3 in5=float3(0.0, 0.0, 0.0),
    uniform int which=int(0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx switch"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    int which_ = which;
    if (which_ == 1) return in2;
    if (which_ == 2) return in3;
    if (which_ == 3) return in4;
    if (which_ >= 4) return in5;
    return in1;
}
export float4 switch_(
    varying float4 in1=float4(0.0, 0.0, 0.0, 0.0),
    varying float4 in2=float4(0.0, 0.0, 0.0, 0.0),
    varying float4 in3=float4(0.0, 0.0, 0.0, 0.0),
    varying float4 in4=float4(0.0, 0.0, 0.0, 0.0),
    varying float4 in5=float4(0.0, 0.0, 0.0, 0.0),
    uniform int which=int(0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx switch"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    int which_ = which;
    if (which_ == 1) return in2;
    if (which_ == 2) return in3;
    if (which_ == 3) return in4;
    if (which_ >= 4) return in5;
    return in1;
}
export float switch_(
    varying float in1=float(0.0),
    varying float in2=float(0.0),
    uniform bool which=bool(false)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx switch"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    if (which) return in2;
    return in1;
}
// Unsupported MaterialX nodedef ND_switch_color2B skipped
export color3 switch_(
    varying color3 in1=color3(0.0, 0.0, 0.0),
    varying color3 in2=color3(0.0, 0.0, 0.0),
    uniform bool which=bool(false)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx switch"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    if (which) return in2;
    return in1;
}
// Unsupported MaterialX nodedef ND_switch_color4B skipped
export float2 switch_(
    varying float2 in1=float2(0.0, 0.0),
    varying float2 in2=float2(0.0, 0.0),
    uniform bool which=bool(false)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx switch"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    if (which) return in2;
    return in1;
}
export float3 switch_(
    varying float3 in1=float3(0.0, 0.0, 0.0),
    varying float3 in2=float3(0.0, 0.0, 0.0),
    uniform bool which=bool(false)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx switch"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    if (which) return in2;
    return in1;
}
export float4 switch_(
    varying float4 in1=float4(0.0, 0.0, 0.0, 0.0),
    varying float4 in2=float4(0.0, 0.0, 0.0, 0.0),
    uniform bool which=bool(false)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx switch"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    if (which) return in2;
    return in1;
}
// Error: Implementation for color2 convert missing
/*export color2 convert_color2(
    varying float in_=float(0.f)){ return color2(0.f, 0.f); }
*/
export color3 convert_color3(
    varying float in_=float(0.f))
[[
    anno::display_name("Matx convert"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{    return mtlx::utilities::to_color3(in_);
}
// Error: Implementation for color4 convert missing
/*export color4 convert_color4(
    varying float in_=float(0.f)){ return color4(0.f, 0.f, 0.f, 0.f); }
*/
export float2 convert_vector2(
    varying float in_=float(0.f))
[[
    anno::display_name("Matx convert"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{    return mtlx::utilities::to_float2(in_);
}
export float3 convert_vector3(
    varying float in_=float(0.f))
[[
    anno::display_name("Matx convert"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{    return mtlx::utilities::to_float3(in_);
}
export float4 convert_vector4(
    varying float in_=float(0.f))
[[
    anno::display_name("Matx convert"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{    return mtlx::utilities::to_float4(in_);
}
// Error: Implementation for color2 convert missing
/*export color2 convert_color2(
    varying float2 in_=float2(0.f,0.f)){ return color2(0.f, 0.f); }
*/
export float3 convert_vector3(
    varying float2 in_=float2(0.f,0.f))
[[
    anno::display_name("Matx convert"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{    return mtlx::utilities::to_float3(in_);
}
export float2 convert_vector2(
    varying float3 in_=float3(0.f,0.f,0.f))
[[
    anno::display_name("Matx convert"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{    return mtlx::utilities::to_float2(in_);
}
export color3 convert_color3(
    varying float3 in_=float3(0.f,0.f,0.f))
[[
    anno::display_name("Matx convert"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{    return mtlx::utilities::to_color3(in_);
}
export float4 convert_vector4(
    varying float3 in_=float3(0.f,0.f,0.f))
[[
    anno::display_name("Matx convert"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{    return mtlx::utilities::to_float4(in_);
}
export float3 convert_vector3(
    varying float4 in_=float4(0.f,0.f,0.f,0.f))
[[
    anno::display_name("Matx convert"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{    return mtlx::utilities::to_float3(in_);
}
// Error: Implementation for color4 convert missing
/*export color4 convert_color4(
    varying float4 in_=float4(0.f,0.f,0.f,0.f)){ return color4(0.f, 0.f, 0.f, 0.f); }
*/
// Unsupported MaterialX nodedef ND_convert_color2_vector2 skipped
export float3 convert_vector3(
    varying color3 in_=color3(0.f, 0.f, 0.f))
[[
    anno::display_name("Matx convert"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{    return mtlx::utilities::to_float3(in_);
}
// Unsupported MaterialX nodedef ND_convert_color4_vector4 skipped
// Error: Implementation for color4 convert missing
/*export color4 convert_color4(
    varying color3 in_=color3(0.f, 0.f, 0.f)){ return color4(0.f, 0.f, 0.f, 0.f); }
*/
// Unsupported MaterialX nodedef ND_convert_color4_color3 skipped
export float convert(
    varying bool in_=bool(false))
[[
    anno::display_name("Matx convert"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{    return mtlx::utilities::to_float(in_);
}
export float convert(
    varying int in_=int(0))
[[
    anno::display_name("Matx convert"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{    return mtlx::utilities::to_float(in_);
}
// Error: Implementation for color2 swizzle missing
/*export color2 swizzle_color2(
    varying float in_=float(0.f),
    uniform string channels=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]]){ return color2(0.f, 0.f); }
*/
export color3 swizzle_color3(
    varying float in_=float(0.f),
    uniform string channels=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx swizzle"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    if     (channels == "rrr") return color3(in_,in_,in_);
    else if(channels == "xxx") return color3(in_,in_,in_);
    else return color3(0.0);
}
// Error: Implementation for color4 swizzle missing
/*export color4 swizzle_color4(
    varying float in_=float(0.f),
    uniform string channels=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]]){ return color4(0.f, 0.f, 0.f, 0.f); }
*/
export float2 swizzle_vector2(
    varying float in_=float(0.f),
    uniform string channels=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx swizzle"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    if     (channels == "rr") return float2(in_,in_);
    else if(channels == "xx") return float2(in_,in_);
    else return float2(0.0);
}
export float3 swizzle_vector3(
    varying float in_=float(0.f),
    uniform string channels=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx swizzle"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    if     (channels == "rrr") return float3(in_,in_,in_);
    else if(channels == "xxx") return float3(in_,in_,in_);
    else return float3(0.0);
}
export float4 swizzle_vector4(
    varying float in_=float(0.f),
    uniform string channels=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx swizzle"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    if     (channels == "rrrr") return float4(in_,in_,in_,in_);
    else if(channels == "xxxx") return float4(in_,in_,in_,in_);
    else return float4(0.0);
}
// Unsupported MaterialX nodedef ND_swizzle_color2_float skipped
// Unsupported MaterialX nodedef ND_swizzle_color2_color2 skipped
// Unsupported MaterialX nodedef ND_swizzle_color2_color3 skipped
// Unsupported MaterialX nodedef ND_swizzle_color2_color4 skipped
// Unsupported MaterialX nodedef ND_swizzle_color2_vector2 skipped
// Unsupported MaterialX nodedef ND_swizzle_color2_vector3 skipped
// Unsupported MaterialX nodedef ND_swizzle_color2_vector4 skipped
export float swizzle_float(
    varying color3 in_=color3(0.f, 0.f, 0.f),
    uniform string channels=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx swizzle"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    float3 fColor(in_);
    if     (channels == "r") return float(fColor.x);
    else if(channels == "g") return float(fColor.y);
    else if(channels == "b") return float(fColor.z);
    else return float(0.0);
}
// Error: Implementation for color2 swizzle missing
/*export color2 swizzle_color2(
    varying color3 in_=color3(0.f, 0.f, 0.f),
    uniform string channels=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]]){ return color2(0.f, 0.f); }
*/
export color3 swizzle_color3(
    varying color3 in_=color3(0.f, 0.f, 0.f),
    uniform string channels=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx swizzle"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    float3 fColor(in_);
    if     (channels == "rrr") return color3(fColor.x,fColor.x,fColor.x);
    else if(channels == "rrg") return color3(fColor.x,fColor.x,fColor.y);
    else if(channels == "rrb") return color3(fColor.x,fColor.x,fColor.z);
    else if(channels == "rgr") return color3(fColor.x,fColor.y,fColor.x);
    else if(channels == "rgg") return color3(fColor.x,fColor.y,fColor.y);
    else if(channels == "rgb") return color3(fColor.x,fColor.y,fColor.z);
    else if(channels == "rbr") return color3(fColor.x,fColor.z,fColor.x);
    else if(channels == "rbg") return color3(fColor.x,fColor.z,fColor.y);
    else if(channels == "rbb") return color3(fColor.x,fColor.z,fColor.z);
    else if(channels == "grr") return color3(fColor.y,fColor.x,fColor.x);
    else if(channels == "grg") return color3(fColor.y,fColor.x,fColor.y);
    else if(channels == "grb") return color3(fColor.y,fColor.x,fColor.z);
    else if(channels == "ggr") return color3(fColor.y,fColor.y,fColor.x);
    else if(channels == "ggg") return color3(fColor.y,fColor.y,fColor.y);
    else if(channels == "ggb") return color3(fColor.y,fColor.y,fColor.z);
    else if(channels == "gbr") return color3(fColor.y,fColor.z,fColor.x);
    else if(channels == "gbg") return color3(fColor.y,fColor.z,fColor.y);
    else if(channels == "gbb") return color3(fColor.y,fColor.z,fColor.z);
    else if(channels == "brr") return color3(fColor.z,fColor.x,fColor.x);
    else if(channels == "brg") return color3(fColor.z,fColor.x,fColor.y);
    else if(channels == "brb") return color3(fColor.z,fColor.x,fColor.z);
    else if(channels == "bgr") return color3(fColor.z,fColor.y,fColor.x);
    else if(channels == "bgg") return color3(fColor.z,fColor.y,fColor.y);
    else if(channels == "bgb") return color3(fColor.z,fColor.y,fColor.z);
    else if(channels == "bbr") return color3(fColor.z,fColor.z,fColor.x);
    else if(channels == "bbg") return color3(fColor.z,fColor.z,fColor.y);
    else if(channels == "bbb") return color3(fColor.z,fColor.z,fColor.z);
    else return color3(0.0);
}
// Error: Implementation for color4 swizzle missing
/*export color4 swizzle_color4(
    varying color3 in_=color3(0.f, 0.f, 0.f),
    uniform string channels=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]]){ return color4(0.f, 0.f, 0.f, 0.f); }
*/
export float2 swizzle_vector2(
    varying color3 in_=color3(0.f, 0.f, 0.f),
    uniform string channels=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx swizzle"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    float3 fColor(in_);
    if     (channels == "rr") return float2(fColor.x,fColor.x);
    else if(channels == "rg") return float2(fColor.x,fColor.y);
    else if(channels == "rb") return float2(fColor.x,fColor.z);
    else if(channels == "gr") return float2(fColor.y,fColor.x);
    else if(channels == "gg") return float2(fColor.y,fColor.y);
    else if(channels == "gb") return float2(fColor.y,fColor.z);
    else if(channels == "br") return float2(fColor.z,fColor.x);
    else if(channels == "bg") return float2(fColor.z,fColor.y);
    else if(channels == "bb") return float2(fColor.z,fColor.z);
    else return float2(0.0);
}
export float3 swizzle_vector3(
    varying color3 in_=color3(0.f, 0.f, 0.f),
    uniform string channels=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx swizzle"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    float3 fColor(in_);
    if     (channels == "rrr") return float3(fColor.x,fColor.x,fColor.x);
    else if(channels == "rrg") return float3(fColor.x,fColor.x,fColor.y);
    else if(channels == "rrb") return float3(fColor.x,fColor.x,fColor.z);
    else if(channels == "rgr") return float3(fColor.x,fColor.y,fColor.x);
    else if(channels == "rgg") return float3(fColor.x,fColor.y,fColor.y);
    else if(channels == "rgb") return float3(fColor.x,fColor.y,fColor.z);
    else if(channels == "rbr") return float3(fColor.x,fColor.z,fColor.x);
    else if(channels == "rbg") return float3(fColor.x,fColor.z,fColor.y);
    else if(channels == "rbb") return float3(fColor.x,fColor.z,fColor.z);
    else if(channels == "grr") return float3(fColor.y,fColor.x,fColor.x);
    else if(channels == "grg") return float3(fColor.y,fColor.x,fColor.y);
    else if(channels == "grb") return float3(fColor.y,fColor.x,fColor.z);
    else if(channels == "ggr") return float3(fColor.y,fColor.y,fColor.x);
    else if(channels == "ggg") return float3(fColor.y,fColor.y,fColor.y);
    else if(channels == "ggb") return float3(fColor.y,fColor.y,fColor.z);
    else if(channels == "gbr") return float3(fColor.y,fColor.z,fColor.x);
    else if(channels == "gbg") return float3(fColor.y,fColor.z,fColor.y);
    else if(channels == "gbb") return float3(fColor.y,fColor.z,fColor.z);
    else if(channels == "brr") return float3(fColor.z,fColor.x,fColor.x);
    else if(channels == "brg") return float3(fColor.z,fColor.x,fColor.y);
    else if(channels == "brb") return float3(fColor.z,fColor.x,fColor.z);
    else if(channels == "bgr") return float3(fColor.z,fColor.y,fColor.x);
    else if(channels == "bgg") return float3(fColor.z,fColor.y,fColor.y);
    else if(channels == "bgb") return float3(fColor.z,fColor.y,fColor.z);
    else if(channels == "bbr") return float3(fColor.z,fColor.z,fColor.x);
    else if(channels == "bbg") return float3(fColor.z,fColor.z,fColor.y);
    else if(channels == "bbb") return float3(fColor.z,fColor.z,fColor.z);
    else return float3(0.0);
}
export float4 swizzle_vector4(
    varying color3 in_=color3(0.f, 0.f, 0.f),
    uniform string channels=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx swizzle"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    float3 fColor(in_);
    if     (channels == "rrrr") return float4(fColor.x,fColor.x,fColor.x,fColor.x);
    else if(channels == "rrrg") return float4(fColor.x,fColor.x,fColor.x,fColor.y);
    else if(channels == "rrrb") return float4(fColor.x,fColor.x,fColor.x,fColor.z);
    else if(channels == "rrgr") return float4(fColor.x,fColor.x,fColor.y,fColor.x);
    else if(channels == "rrgg") return float4(fColor.x,fColor.x,fColor.y,fColor.y);
    else if(channels == "rrgb") return float4(fColor.x,fColor.x,fColor.y,fColor.z);
    else if(channels == "rrbr") return float4(fColor.x,fColor.x,fColor.z,fColor.x);
    else if(channels == "rrbg") return float4(fColor.x,fColor.x,fColor.z,fColor.y);
    else if(channels == "rrbb") return float4(fColor.x,fColor.x,fColor.z,fColor.z);
    else if(channels == "rgrr") return float4(fColor.x,fColor.y,fColor.x,fColor.x);
    else if(channels == "rgrg") return float4(fColor.x,fColor.y,fColor.x,fColor.y);
    else if(channels == "rgrb") return float4(fColor.x,fColor.y,fColor.x,fColor.z);
    else if(channels == "rggr") return float4(fColor.x,fColor.y,fColor.y,fColor.x);
    else if(channels == "rggg") return float4(fColor.x,fColor.y,fColor.y,fColor.y);
    else if(channels == "rggb") return float4(fColor.x,fColor.y,fColor.y,fColor.z);
    else if(channels == "rgbr") return float4(fColor.x,fColor.y,fColor.z,fColor.x);
    else if(channels == "rgbg") return float4(fColor.x,fColor.y,fColor.z,fColor.y);
    else if(channels == "rgbb") return float4(fColor.x,fColor.y,fColor.z,fColor.z);
    else if(channels == "rbrr") return float4(fColor.x,fColor.z,fColor.x,fColor.x);
    else if(channels == "rbrg") return float4(fColor.x,fColor.z,fColor.x,fColor.y);
    else if(channels == "rbrb") return float4(fColor.x,fColor.z,fColor.x,fColor.z);
    else if(channels == "rbgr") return float4(fColor.x,fColor.z,fColor.y,fColor.x);
    else if(channels == "rbgg") return float4(fColor.x,fColor.z,fColor.y,fColor.y);
    else if(channels == "rbgb") return float4(fColor.x,fColor.z,fColor.y,fColor.z);
    else if(channels == "rbbr") return float4(fColor.x,fColor.z,fColor.z,fColor.x);
    else if(channels == "rbbg") return float4(fColor.x,fColor.z,fColor.z,fColor.y);
    else if(channels == "rbbb") return float4(fColor.x,fColor.z,fColor.z,fColor.z);
    else if(channels == "grrr") return float4(fColor.y,fColor.x,fColor.x,fColor.x);
    else if(channels == "grrg") return float4(fColor.y,fColor.x,fColor.x,fColor.y);
    else if(channels == "grrb") return float4(fColor.y,fColor.x,fColor.x,fColor.z);
    else if(channels == "grgr") return float4(fColor.y,fColor.x,fColor.y,fColor.x);
    else if(channels == "grgg") return float4(fColor.y,fColor.x,fColor.y,fColor.y);
    else if(channels == "grgb") return float4(fColor.y,fColor.x,fColor.y,fColor.z);
    else if(channels == "grbr") return float4(fColor.y,fColor.x,fColor.z,fColor.x);
    else if(channels == "grbg") return float4(fColor.y,fColor.x,fColor.z,fColor.y);
    else if(channels == "grbb") return float4(fColor.y,fColor.x,fColor.z,fColor.z);
    else if(channels == "ggrr") return float4(fColor.y,fColor.y,fColor.x,fColor.x);
    else if(channels == "ggrg") return float4(fColor.y,fColor.y,fColor.x,fColor.y);
    else if(channels == "ggrb") return float4(fColor.y,fColor.y,fColor.x,fColor.z);
    else if(channels == "gggr") return float4(fColor.y,fColor.y,fColor.y,fColor.x);
    else if(channels == "gggg") return float4(fColor.y,fColor.y,fColor.y,fColor.y);
    else if(channels == "gggb") return float4(fColor.y,fColor.y,fColor.y,fColor.z);
    else if(channels == "ggbr") return float4(fColor.y,fColor.y,fColor.z,fColor.x);
    else if(channels == "ggbg") return float4(fColor.y,fColor.y,fColor.z,fColor.y);
    else if(channels == "ggbb") return float4(fColor.y,fColor.y,fColor.z,fColor.z);
    else if(channels == "gbrr") return float4(fColor.y,fColor.z,fColor.x,fColor.x);
    else if(channels == "gbrg") return float4(fColor.y,fColor.z,fColor.x,fColor.y);
    else if(channels == "gbrb") return float4(fColor.y,fColor.z,fColor.x,fColor.z);
    else if(channels == "gbgr") return float4(fColor.y,fColor.z,fColor.y,fColor.x);
    else if(channels == "gbgg") return float4(fColor.y,fColor.z,fColor.y,fColor.y);
    else if(channels == "gbgb") return float4(fColor.y,fColor.z,fColor.y,fColor.z);
    else if(channels == "gbbr") return float4(fColor.y,fColor.z,fColor.z,fColor.x);
    else if(channels == "gbbg") return float4(fColor.y,fColor.z,fColor.z,fColor.y);
    else if(channels == "gbbb") return float4(fColor.y,fColor.z,fColor.z,fColor.z);
    else if(channels == "brrr") return float4(fColor.z,fColor.x,fColor.x,fColor.x);
    else if(channels == "brrg") return float4(fColor.z,fColor.x,fColor.x,fColor.y);
    else if(channels == "brrb") return float4(fColor.z,fColor.x,fColor.x,fColor.z);
    else if(channels == "brgr") return float4(fColor.z,fColor.x,fColor.y,fColor.x);
    else if(channels == "brgg") return float4(fColor.z,fColor.x,fColor.y,fColor.y);
    else if(channels == "brgb") return float4(fColor.z,fColor.x,fColor.y,fColor.z);
    else if(channels == "brbr") return float4(fColor.z,fColor.x,fColor.z,fColor.x);
    else if(channels == "brbg") return float4(fColor.z,fColor.x,fColor.z,fColor.y);
    else if(channels == "brbb") return float4(fColor.z,fColor.x,fColor.z,fColor.z);
    else if(channels == "bgrr") return float4(fColor.z,fColor.y,fColor.x,fColor.x);
    else if(channels == "bgrg") return float4(fColor.z,fColor.y,fColor.x,fColor.y);
    else if(channels == "bgrb") return float4(fColor.z,fColor.y,fColor.x,fColor.z);
    else if(channels == "bggr") return float4(fColor.z,fColor.y,fColor.y,fColor.x);
    else if(channels == "bggg") return float4(fColor.z,fColor.y,fColor.y,fColor.y);
    else if(channels == "bggb") return float4(fColor.z,fColor.y,fColor.y,fColor.z);
    else if(channels == "bgbr") return float4(fColor.z,fColor.y,fColor.z,fColor.x);
    else if(channels == "bgbg") return float4(fColor.z,fColor.y,fColor.z,fColor.y);
    else if(channels == "bgbb") return float4(fColor.z,fColor.y,fColor.z,fColor.z);
    else if(channels == "bbrr") return float4(fColor.z,fColor.z,fColor.x,fColor.x);
    else if(channels == "bbrg") return float4(fColor.z,fColor.z,fColor.x,fColor.y);
    else if(channels == "bbrb") return float4(fColor.z,fColor.z,fColor.x,fColor.z);
    else if(channels == "bbgr") return float4(fColor.z,fColor.z,fColor.y,fColor.x);
    else if(channels == "bbgg") return float4(fColor.z,fColor.z,fColor.y,fColor.y);
    else if(channels == "bbgb") return float4(fColor.z,fColor.z,fColor.y,fColor.z);
    else if(channels == "bbbr") return float4(fColor.z,fColor.z,fColor.z,fColor.x);
    else if(channels == "bbbg") return float4(fColor.z,fColor.z,fColor.z,fColor.y);
    else if(channels == "bbbb") return float4(fColor.z,fColor.z,fColor.z,fColor.z);
    else return float4(0.0);
}
// Unsupported MaterialX nodedef ND_swizzle_color4_float skipped
// Unsupported MaterialX nodedef ND_swizzle_color4_color2 skipped
// Unsupported MaterialX nodedef ND_swizzle_color4_color3 skipped
// Unsupported MaterialX nodedef ND_swizzle_color4_color4 skipped
// Unsupported MaterialX nodedef ND_swizzle_color4_vector2 skipped
// Unsupported MaterialX nodedef ND_swizzle_color4_vector3 skipped
// Unsupported MaterialX nodedef ND_swizzle_color4_vector4 skipped
export float swizzle_float(
    varying float2 in_=float2(0.f,0.f),
    uniform string channels=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx swizzle"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    if     (channels == "x") return float(in_.x);
    else if(channels == "y") return float(in_.y);
    else return float(0.0);
}
// Error: Implementation for color2 swizzle missing
/*export color2 swizzle_color2(
    varying float2 in_=float2(0.f,0.f),
    uniform string channels=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]]){ return color2(0.f, 0.f); }
*/
export color3 swizzle_color3(
    varying float2 in_=float2(0.f,0.f),
    uniform string channels=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx swizzle"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    if     (channels == "xxx") return color3(in_.x,in_.x,in_.x);
    else if(channels == "xxy") return color3(in_.x,in_.x,in_.y);
    else if(channels == "xyx") return color3(in_.x,in_.y,in_.x);
    else if(channels == "xyy") return color3(in_.x,in_.y,in_.y);
    else if(channels == "yxx") return color3(in_.y,in_.x,in_.x);
    else if(channels == "yxy") return color3(in_.y,in_.x,in_.y);
    else if(channels == "yyx") return color3(in_.y,in_.y,in_.x);
    else if(channels == "yyy") return color3(in_.y,in_.y,in_.y);
    else return color3(0.0);
}
// Error: Implementation for color4 swizzle missing
/*export color4 swizzle_color4(
    varying float2 in_=float2(0.f,0.f),
    uniform string channels=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]]){ return color4(0.f, 0.f, 0.f, 0.f); }
*/
export float2 swizzle_vector2(
    varying float2 in_=float2(0.f,0.f),
    uniform string channels=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx swizzle"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    if     (channels == "xx") return float2(in_.x,in_.x);
    else if(channels == "xy") return float2(in_.x,in_.y);
    else if(channels == "yx") return float2(in_.y,in_.x);
    else if(channels == "yy") return float2(in_.y,in_.y);
    else return float2(0.0);
}
export float3 swizzle_vector3(
    varying float2 in_=float2(0.f,0.f),
    uniform string channels=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx swizzle"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    if     (channels == "xxx") return float3(in_.x,in_.x,in_.x);
    else if(channels == "xxy") return float3(in_.x,in_.x,in_.y);
    else if(channels == "xyx") return float3(in_.x,in_.y,in_.x);
    else if(channels == "xyy") return float3(in_.x,in_.y,in_.y);
    else if(channels == "yxx") return float3(in_.y,in_.x,in_.x);
    else if(channels == "yxy") return float3(in_.y,in_.x,in_.y);
    else if(channels == "yyx") return float3(in_.y,in_.y,in_.x);
    else if(channels == "yyy") return float3(in_.y,in_.y,in_.y);
    else return float3(0.0);
}
export float4 swizzle_vector4(
    varying float2 in_=float2(0.f,0.f),
    uniform string channels=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx swizzle"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    if     (channels == "xxxx") return float4(in_.x,in_.x,in_.x,in_.x);
    else if(channels == "xxxy") return float4(in_.x,in_.x,in_.x,in_.y);
    else if(channels == "xxyx") return float4(in_.x,in_.x,in_.y,in_.x);
    else if(channels == "xxyy") return float4(in_.x,in_.x,in_.y,in_.y);
    else if(channels == "xyxx") return float4(in_.x,in_.y,in_.x,in_.x);
    else if(channels == "xyxy") return float4(in_.x,in_.y,in_.x,in_.y);
    else if(channels == "xyyx") return float4(in_.x,in_.y,in_.y,in_.x);
    else if(channels == "xyyy") return float4(in_.x,in_.y,in_.y,in_.y);
    else if(channels == "yxxx") return float4(in_.y,in_.x,in_.x,in_.x);
    else if(channels == "yxxy") return float4(in_.y,in_.x,in_.x,in_.y);
    else if(channels == "yxyx") return float4(in_.y,in_.x,in_.y,in_.x);
    else if(channels == "yxyy") return float4(in_.y,in_.x,in_.y,in_.y);
    else if(channels == "yyxx") return float4(in_.y,in_.y,in_.x,in_.x);
    else if(channels == "yyxy") return float4(in_.y,in_.y,in_.x,in_.y);
    else if(channels == "yyyx") return float4(in_.y,in_.y,in_.y,in_.x);
    else if(channels == "yyyy") return float4(in_.y,in_.y,in_.y,in_.y);
    else return float4(0.0);
}
export float swizzle_float(
    varying float3 in_=float3(0.f,0.f,0.f),
    uniform string channels=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx swizzle"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    if     (channels == "x") return float(in_.x);
    else if(channels == "y") return float(in_.y);
    else if(channels == "z") return float(in_.z);
    else return float(0.0);
}
// Error: Implementation for color2 swizzle missing
/*export color2 swizzle_color2(
    varying float3 in_=float3(0.f,0.f,0.f),
    uniform string channels=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]]){ return color2(0.f, 0.f); }
*/
export color3 swizzle_color3(
    varying float3 in_=float3(0.f,0.f,0.f),
    uniform string channels=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx swizzle"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    if     (channels == "xxx") return color3(in_.x,in_.x,in_.x);
    else if(channels == "xxy") return color3(in_.x,in_.x,in_.y);
    else if(channels == "xxz") return color3(in_.x,in_.x,in_.z);
    else if(channels == "xyx") return color3(in_.x,in_.y,in_.x);
    else if(channels == "xyy") return color3(in_.x,in_.y,in_.y);
    else if(channels == "xyz") return color3(in_.x,in_.y,in_.z);
    else if(channels == "xzx") return color3(in_.x,in_.z,in_.x);
    else if(channels == "xzy") return color3(in_.x,in_.z,in_.y);
    else if(channels == "xzz") return color3(in_.x,in_.z,in_.z);
    else if(channels == "yxx") return color3(in_.y,in_.x,in_.x);
    else if(channels == "yxy") return color3(in_.y,in_.x,in_.y);
    else if(channels == "yxz") return color3(in_.y,in_.x,in_.z);
    else if(channels == "yyx") return color3(in_.y,in_.y,in_.x);
    else if(channels == "yyy") return color3(in_.y,in_.y,in_.y);
    else if(channels == "yyz") return color3(in_.y,in_.y,in_.z);
    else if(channels == "yzx") return color3(in_.y,in_.z,in_.x);
    else if(channels == "yzy") return color3(in_.y,in_.z,in_.y);
    else if(channels == "yzz") return color3(in_.y,in_.z,in_.z);
    else if(channels == "zxx") return color3(in_.z,in_.x,in_.x);
    else if(channels == "zxy") return color3(in_.z,in_.x,in_.y);
    else if(channels == "zxz") return color3(in_.z,in_.x,in_.z);
    else if(channels == "zyx") return color3(in_.z,in_.y,in_.x);
    else if(channels == "zyy") return color3(in_.z,in_.y,in_.y);
    else if(channels == "zyz") return color3(in_.z,in_.y,in_.z);
    else if(channels == "zzx") return color3(in_.z,in_.z,in_.x);
    else if(channels == "zzy") return color3(in_.z,in_.z,in_.y);
    else if(channels == "zzz") return color3(in_.z,in_.z,in_.z);
    else return color3(0.0);
}
// Error: Implementation for color4 swizzle missing
/*export color4 swizzle_color4(
    varying float3 in_=float3(0.f,0.f,0.f),
    uniform string channels=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]]){ return color4(0.f, 0.f, 0.f, 0.f); }
*/
export float2 swizzle_vector2(
    varying float3 in_=float3(0.f,0.f,0.f),
    uniform string channels=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx swizzle"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    if     (channels == "xx") return float2(in_.x,in_.x);
    else if(channels == "xy") return float2(in_.x,in_.y);
    else if(channels == "xz") return float2(in_.x,in_.z);
    else if(channels == "yx") return float2(in_.y,in_.x);
    else if(channels == "yy") return float2(in_.y,in_.y);
    else if(channels == "yz") return float2(in_.y,in_.z);
    else if(channels == "zx") return float2(in_.z,in_.x);
    else if(channels == "zy") return float2(in_.z,in_.y);
    else if(channels == "zz") return float2(in_.z,in_.z);
    else return float2(0.0);
}
export float3 swizzle_vector3(
    varying float3 in_=float3(0.f,0.f,0.f),
    uniform string channels=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx swizzle"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    if     (channels == "xxx") return float3(in_.x,in_.x,in_.x);
    else if(channels == "xxy") return float3(in_.x,in_.x,in_.y);
    else if(channels == "xxz") return float3(in_.x,in_.x,in_.z);
    else if(channels == "xyx") return float3(in_.x,in_.y,in_.x);
    else if(channels == "xyy") return float3(in_.x,in_.y,in_.y);
    else if(channels == "xyz") return float3(in_.x,in_.y,in_.z);
    else if(channels == "xzx") return float3(in_.x,in_.z,in_.x);
    else if(channels == "xzy") return float3(in_.x,in_.z,in_.y);
    else if(channels == "xzz") return float3(in_.x,in_.z,in_.z);
    else if(channels == "yxx") return float3(in_.y,in_.x,in_.x);
    else if(channels == "yxy") return float3(in_.y,in_.x,in_.y);
    else if(channels == "yxz") return float3(in_.y,in_.x,in_.z);
    else if(channels == "yyx") return float3(in_.y,in_.y,in_.x);
    else if(channels == "yyy") return float3(in_.y,in_.y,in_.y);
    else if(channels == "yyz") return float3(in_.y,in_.y,in_.z);
    else if(channels == "yzx") return float3(in_.y,in_.z,in_.x);
    else if(channels == "yzy") return float3(in_.y,in_.z,in_.y);
    else if(channels == "yzz") return float3(in_.y,in_.z,in_.z);
    else if(channels == "zxx") return float3(in_.z,in_.x,in_.x);
    else if(channels == "zxy") return float3(in_.z,in_.x,in_.y);
    else if(channels == "zxz") return float3(in_.z,in_.x,in_.z);
    else if(channels == "zyx") return float3(in_.z,in_.y,in_.x);
    else if(channels == "zyy") return float3(in_.z,in_.y,in_.y);
    else if(channels == "zyz") return float3(in_.z,in_.y,in_.z);
    else if(channels == "zzx") return float3(in_.z,in_.z,in_.x);
    else if(channels == "zzy") return float3(in_.z,in_.z,in_.y);
    else if(channels == "zzz") return float3(in_.z,in_.z,in_.z);
    else return float3(0.0);
}
export float4 swizzle_vector4(
    varying float3 in_=float3(0.f,0.f,0.f),
    uniform string channels=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx swizzle"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    if     (channels == "xxxx") return float4(in_.x,in_.x,in_.x,in_.x);
    else if(channels == "xxxy") return float4(in_.x,in_.x,in_.x,in_.y);
    else if(channels == "xxxz") return float4(in_.x,in_.x,in_.x,in_.z);
    else if(channels == "xxyx") return float4(in_.x,in_.x,in_.y,in_.x);
    else if(channels == "xxyy") return float4(in_.x,in_.x,in_.y,in_.y);
    else if(channels == "xxyz") return float4(in_.x,in_.x,in_.y,in_.z);
    else if(channels == "xxzx") return float4(in_.x,in_.x,in_.z,in_.x);
    else if(channels == "xxzy") return float4(in_.x,in_.x,in_.z,in_.y);
    else if(channels == "xxzz") return float4(in_.x,in_.x,in_.z,in_.z);
    else if(channels == "xyxx") return float4(in_.x,in_.y,in_.x,in_.x);
    else if(channels == "xyxy") return float4(in_.x,in_.y,in_.x,in_.y);
    else if(channels == "xyxz") return float4(in_.x,in_.y,in_.x,in_.z);
    else if(channels == "xyyx") return float4(in_.x,in_.y,in_.y,in_.x);
    else if(channels == "xyyy") return float4(in_.x,in_.y,in_.y,in_.y);
    else if(channels == "xyyz") return float4(in_.x,in_.y,in_.y,in_.z);
    else if(channels == "xyzx") return float4(in_.x,in_.y,in_.z,in_.x);
    else if(channels == "xyzy") return float4(in_.x,in_.y,in_.z,in_.y);
    else if(channels == "xyzz") return float4(in_.x,in_.y,in_.z,in_.z);
    else if(channels == "xzxx") return float4(in_.x,in_.z,in_.x,in_.x);
    else if(channels == "xzxy") return float4(in_.x,in_.z,in_.x,in_.y);
    else if(channels == "xzxz") return float4(in_.x,in_.z,in_.x,in_.z);
    else if(channels == "xzyx") return float4(in_.x,in_.z,in_.y,in_.x);
    else if(channels == "xzyy") return float4(in_.x,in_.z,in_.y,in_.y);
    else if(channels == "xzyz") return float4(in_.x,in_.z,in_.y,in_.z);
    else if(channels == "xzzx") return float4(in_.x,in_.z,in_.z,in_.x);
    else if(channels == "xzzy") return float4(in_.x,in_.z,in_.z,in_.y);
    else if(channels == "xzzz") return float4(in_.x,in_.z,in_.z,in_.z);
    else if(channels == "yxxx") return float4(in_.y,in_.x,in_.x,in_.x);
    else if(channels == "yxxy") return float4(in_.y,in_.x,in_.x,in_.y);
    else if(channels == "yxxz") return float4(in_.y,in_.x,in_.x,in_.z);
    else if(channels == "yxyx") return float4(in_.y,in_.x,in_.y,in_.x);
    else if(channels == "yxyy") return float4(in_.y,in_.x,in_.y,in_.y);
    else if(channels == "yxyz") return float4(in_.y,in_.x,in_.y,in_.z);
    else if(channels == "yxzx") return float4(in_.y,in_.x,in_.z,in_.x);
    else if(channels == "yxzy") return float4(in_.y,in_.x,in_.z,in_.y);
    else if(channels == "yxzz") return float4(in_.y,in_.x,in_.z,in_.z);
    else if(channels == "yyxx") return float4(in_.y,in_.y,in_.x,in_.x);
    else if(channels == "yyxy") return float4(in_.y,in_.y,in_.x,in_.y);
    else if(channels == "yyxz") return float4(in_.y,in_.y,in_.x,in_.z);
    else if(channels == "yyyx") return float4(in_.y,in_.y,in_.y,in_.x);
    else if(channels == "yyyy") return float4(in_.y,in_.y,in_.y,in_.y);
    else if(channels == "yyyz") return float4(in_.y,in_.y,in_.y,in_.z);
    else if(channels == "yyzx") return float4(in_.y,in_.y,in_.z,in_.x);
    else if(channels == "yyzy") return float4(in_.y,in_.y,in_.z,in_.y);
    else if(channels == "yyzz") return float4(in_.y,in_.y,in_.z,in_.z);
    else if(channels == "yzxx") return float4(in_.y,in_.z,in_.x,in_.x);
    else if(channels == "yzxy") return float4(in_.y,in_.z,in_.x,in_.y);
    else if(channels == "yzxz") return float4(in_.y,in_.z,in_.x,in_.z);
    else if(channels == "yzyx") return float4(in_.y,in_.z,in_.y,in_.x);
    else if(channels == "yzyy") return float4(in_.y,in_.z,in_.y,in_.y);
    else if(channels == "yzyz") return float4(in_.y,in_.z,in_.y,in_.z);
    else if(channels == "yzzx") return float4(in_.y,in_.z,in_.z,in_.x);
    else if(channels == "yzzy") return float4(in_.y,in_.z,in_.z,in_.y);
    else if(channels == "yzzz") return float4(in_.y,in_.z,in_.z,in_.z);
    else if(channels == "zxxx") return float4(in_.z,in_.x,in_.x,in_.x);
    else if(channels == "zxxy") return float4(in_.z,in_.x,in_.x,in_.y);
    else if(channels == "zxxz") return float4(in_.z,in_.x,in_.x,in_.z);
    else if(channels == "zxyx") return float4(in_.z,in_.x,in_.y,in_.x);
    else if(channels == "zxyy") return float4(in_.z,in_.x,in_.y,in_.y);
    else if(channels == "zxyz") return float4(in_.z,in_.x,in_.y,in_.z);
    else if(channels == "zxzx") return float4(in_.z,in_.x,in_.z,in_.x);
    else if(channels == "zxzy") return float4(in_.z,in_.x,in_.z,in_.y);
    else if(channels == "zxzz") return float4(in_.z,in_.x,in_.z,in_.z);
    else if(channels == "zyxx") return float4(in_.z,in_.y,in_.x,in_.x);
    else if(channels == "zyxy") return float4(in_.z,in_.y,in_.x,in_.y);
    else if(channels == "zyxz") return float4(in_.z,in_.y,in_.x,in_.z);
    else if(channels == "zyyx") return float4(in_.z,in_.y,in_.y,in_.x);
    else if(channels == "zyyy") return float4(in_.z,in_.y,in_.y,in_.y);
    else if(channels == "zyyz") return float4(in_.z,in_.y,in_.y,in_.z);
    else if(channels == "zyzx") return float4(in_.z,in_.y,in_.z,in_.x);
    else if(channels == "zyzy") return float4(in_.z,in_.y,in_.z,in_.y);
    else if(channels == "zyzz") return float4(in_.z,in_.y,in_.z,in_.z);
    else if(channels == "zzxx") return float4(in_.z,in_.z,in_.x,in_.x);
    else if(channels == "zzxy") return float4(in_.z,in_.z,in_.x,in_.y);
    else if(channels == "zzxz") return float4(in_.z,in_.z,in_.x,in_.z);
    else if(channels == "zzyx") return float4(in_.z,in_.z,in_.y,in_.x);
    else if(channels == "zzyy") return float4(in_.z,in_.z,in_.y,in_.y);
    else if(channels == "zzyz") return float4(in_.z,in_.z,in_.y,in_.z);
    else if(channels == "zzzx") return float4(in_.z,in_.z,in_.z,in_.x);
    else if(channels == "zzzy") return float4(in_.z,in_.z,in_.z,in_.y);
    else if(channels == "zzzz") return float4(in_.z,in_.z,in_.z,in_.z);
    else return float4(0.0);
}
export float swizzle_float(
    varying float4 in_=float4(0.f,0.f,0.f,0.f),
    uniform string channels=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx swizzle"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    if     (channels == "x") return float(in_.x);
    else if(channels == "y") return float(in_.y);
    else if(channels == "z") return float(in_.z);
    else if(channels == "w") return float(in_.w);
    else return float(0.0);
}
// Error: Implementation for color2 swizzle missing
/*export color2 swizzle_color2(
    varying float4 in_=float4(0.f,0.f,0.f,0.f),
    uniform string channels=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]]){ return color2(0.f, 0.f); }
*/
export color3 swizzle_color3(
    varying float4 in_=float4(0.f,0.f,0.f,0.f),
    uniform string channels=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx swizzle"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    if     (channels == "xxx") return color3(in_.x,in_.x,in_.x);
    else if(channels == "xxy") return color3(in_.x,in_.x,in_.y);
    else if(channels == "xxz") return color3(in_.x,in_.x,in_.z);
    else if(channels == "xxw") return color3(in_.x,in_.x,in_.w);
    else if(channels == "xyx") return color3(in_.x,in_.y,in_.x);
    else if(channels == "xyy") return color3(in_.x,in_.y,in_.y);
    else if(channels == "xyz") return color3(in_.x,in_.y,in_.z);
    else if(channels == "xyw") return color3(in_.x,in_.y,in_.w);
    else if(channels == "xzx") return color3(in_.x,in_.z,in_.x);
    else if(channels == "xzy") return color3(in_.x,in_.z,in_.y);
    else if(channels == "xzz") return color3(in_.x,in_.z,in_.z);
    else if(channels == "xzw") return color3(in_.x,in_.z,in_.w);
    else if(channels == "xwx") return color3(in_.x,in_.w,in_.x);
    else if(channels == "xwy") return color3(in_.x,in_.w,in_.y);
    else if(channels == "xwz") return color3(in_.x,in_.w,in_.z);
    else if(channels == "xww") return color3(in_.x,in_.w,in_.w);
    else if(channels == "yxx") return color3(in_.y,in_.x,in_.x);
    else if(channels == "yxy") return color3(in_.y,in_.x,in_.y);
    else if(channels == "yxz") return color3(in_.y,in_.x,in_.z);
    else if(channels == "yxw") return color3(in_.y,in_.x,in_.w);
    else if(channels == "yyx") return color3(in_.y,in_.y,in_.x);
    else if(channels == "yyy") return color3(in_.y,in_.y,in_.y);
    else if(channels == "yyz") return color3(in_.y,in_.y,in_.z);
    else if(channels == "yyw") return color3(in_.y,in_.y,in_.w);
    else if(channels == "yzx") return color3(in_.y,in_.z,in_.x);
    else if(channels == "yzy") return color3(in_.y,in_.z,in_.y);
    else if(channels == "yzz") return color3(in_.y,in_.z,in_.z);
    else if(channels == "yzw") return color3(in_.y,in_.z,in_.w);
    else if(channels == "ywx") return color3(in_.y,in_.w,in_.x);
    else if(channels == "ywy") return color3(in_.y,in_.w,in_.y);
    else if(channels == "ywz") return color3(in_.y,in_.w,in_.z);
    else if(channels == "yww") return color3(in_.y,in_.w,in_.w);
    else if(channels == "zxx") return color3(in_.z,in_.x,in_.x);
    else if(channels == "zxy") return color3(in_.z,in_.x,in_.y);
    else if(channels == "zxz") return color3(in_.z,in_.x,in_.z);
    else if(channels == "zxw") return color3(in_.z,in_.x,in_.w);
    else if(channels == "zyx") return color3(in_.z,in_.y,in_.x);
    else if(channels == "zyy") return color3(in_.z,in_.y,in_.y);
    else if(channels == "zyz") return color3(in_.z,in_.y,in_.z);
    else if(channels == "zyw") return color3(in_.z,in_.y,in_.w);
    else if(channels == "zzx") return color3(in_.z,in_.z,in_.x);
    else if(channels == "zzy") return color3(in_.z,in_.z,in_.y);
    else if(channels == "zzz") return color3(in_.z,in_.z,in_.z);
    else if(channels == "zzw") return color3(in_.z,in_.z,in_.w);
    else if(channels == "zwx") return color3(in_.z,in_.w,in_.x);
    else if(channels == "zwy") return color3(in_.z,in_.w,in_.y);
    else if(channels == "zwz") return color3(in_.z,in_.w,in_.z);
    else if(channels == "zww") return color3(in_.z,in_.w,in_.w);
    else if(channels == "wxx") return color3(in_.w,in_.x,in_.x);
    else if(channels == "wxy") return color3(in_.w,in_.x,in_.y);
    else if(channels == "wxz") return color3(in_.w,in_.x,in_.z);
    else if(channels == "wxw") return color3(in_.w,in_.x,in_.w);
    else if(channels == "wyx") return color3(in_.w,in_.y,in_.x);
    else if(channels == "wyy") return color3(in_.w,in_.y,in_.y);
    else if(channels == "wyz") return color3(in_.w,in_.y,in_.z);
    else if(channels == "wyw") return color3(in_.w,in_.y,in_.w);
    else if(channels == "wzx") return color3(in_.w,in_.z,in_.x);
    else if(channels == "wzy") return color3(in_.w,in_.z,in_.y);
    else if(channels == "wzz") return color3(in_.w,in_.z,in_.z);
    else if(channels == "wzw") return color3(in_.w,in_.z,in_.w);
    else if(channels == "wwx") return color3(in_.w,in_.w,in_.x);
    else if(channels == "wwy") return color3(in_.w,in_.w,in_.y);
    else if(channels == "wwz") return color3(in_.w,in_.w,in_.z);
    else if(channels == "www") return color3(in_.w,in_.w,in_.w);
    else return color3(0.0);
}
// Error: Implementation for color4 swizzle missing
/*export color4 swizzle_color4(
    varying float4 in_=float4(0.f,0.f,0.f,0.f),
    uniform string channels=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]]){ return color4(0.f, 0.f, 0.f, 0.f); }
*/
export float2 swizzle_vector2(
    varying float4 in_=float4(0.f,0.f,0.f,0.f),
    uniform string channels=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx swizzle"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    if     (channels == "xx") return float2(in_.x,in_.x);
    else if(channels == "xy") return float2(in_.x,in_.y);
    else if(channels == "xz") return float2(in_.x,in_.z);
    else if(channels == "xw") return float2(in_.x,in_.w);
    else if(channels == "yx") return float2(in_.y,in_.x);
    else if(channels == "yy") return float2(in_.y,in_.y);
    else if(channels == "yz") return float2(in_.y,in_.z);
    else if(channels == "yw") return float2(in_.y,in_.w);
    else if(channels == "zx") return float2(in_.z,in_.x);
    else if(channels == "zy") return float2(in_.z,in_.y);
    else if(channels == "zz") return float2(in_.z,in_.z);
    else if(channels == "zw") return float2(in_.z,in_.w);
    else if(channels == "wx") return float2(in_.w,in_.x);
    else if(channels == "wy") return float2(in_.w,in_.y);
    else if(channels == "wz") return float2(in_.w,in_.z);
    else if(channels == "ww") return float2(in_.w,in_.w);
    else return float2(0.0);
}
export float3 swizzle_vector3(
    varying float4 in_=float4(0.f,0.f,0.f,0.f),
    uniform string channels=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx swizzle"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    if     (channels == "xxx") return float3(in_.x,in_.x,in_.x);
    else if(channels == "xxy") return float3(in_.x,in_.x,in_.y);
    else if(channels == "xxz") return float3(in_.x,in_.x,in_.z);
    else if(channels == "xxw") return float3(in_.x,in_.x,in_.w);
    else if(channels == "xyx") return float3(in_.x,in_.y,in_.x);
    else if(channels == "xyy") return float3(in_.x,in_.y,in_.y);
    else if(channels == "xyz") return float3(in_.x,in_.y,in_.z);
    else if(channels == "xyw") return float3(in_.x,in_.y,in_.w);
    else if(channels == "xzx") return float3(in_.x,in_.z,in_.x);
    else if(channels == "xzy") return float3(in_.x,in_.z,in_.y);
    else if(channels == "xzz") return float3(in_.x,in_.z,in_.z);
    else if(channels == "xzw") return float3(in_.x,in_.z,in_.w);
    else if(channels == "xwx") return float3(in_.x,in_.w,in_.x);
    else if(channels == "xwy") return float3(in_.x,in_.w,in_.y);
    else if(channels == "xwz") return float3(in_.x,in_.w,in_.z);
    else if(channels == "xww") return float3(in_.x,in_.w,in_.w);
    else if(channels == "yxx") return float3(in_.y,in_.x,in_.x);
    else if(channels == "yxy") return float3(in_.y,in_.x,in_.y);
    else if(channels == "yxz") return float3(in_.y,in_.x,in_.z);
    else if(channels == "yxw") return float3(in_.y,in_.x,in_.w);
    else if(channels == "yyx") return float3(in_.y,in_.y,in_.x);
    else if(channels == "yyy") return float3(in_.y,in_.y,in_.y);
    else if(channels == "yyz") return float3(in_.y,in_.y,in_.z);
    else if(channels == "yyw") return float3(in_.y,in_.y,in_.w);
    else if(channels == "yzx") return float3(in_.y,in_.z,in_.x);
    else if(channels == "yzy") return float3(in_.y,in_.z,in_.y);
    else if(channels == "yzz") return float3(in_.y,in_.z,in_.z);
    else if(channels == "yzw") return float3(in_.y,in_.z,in_.w);
    else if(channels == "ywx") return float3(in_.y,in_.w,in_.x);
    else if(channels == "ywy") return float3(in_.y,in_.w,in_.y);
    else if(channels == "ywz") return float3(in_.y,in_.w,in_.z);
    else if(channels == "yww") return float3(in_.y,in_.w,in_.w);
    else if(channels == "zxx") return float3(in_.z,in_.x,in_.x);
    else if(channels == "zxy") return float3(in_.z,in_.x,in_.y);
    else if(channels == "zxz") return float3(in_.z,in_.x,in_.z);
    else if(channels == "zxw") return float3(in_.z,in_.x,in_.w);
    else if(channels == "zyx") return float3(in_.z,in_.y,in_.x);
    else if(channels == "zyy") return float3(in_.z,in_.y,in_.y);
    else if(channels == "zyz") return float3(in_.z,in_.y,in_.z);
    else if(channels == "zyw") return float3(in_.z,in_.y,in_.w);
    else if(channels == "zzx") return float3(in_.z,in_.z,in_.x);
    else if(channels == "zzy") return float3(in_.z,in_.z,in_.y);
    else if(channels == "zzz") return float3(in_.z,in_.z,in_.z);
    else if(channels == "zzw") return float3(in_.z,in_.z,in_.w);
    else if(channels == "zwx") return float3(in_.z,in_.w,in_.x);
    else if(channels == "zwy") return float3(in_.z,in_.w,in_.y);
    else if(channels == "zwz") return float3(in_.z,in_.w,in_.z);
    else if(channels == "zww") return float3(in_.z,in_.w,in_.w);
    else if(channels == "wxx") return float3(in_.w,in_.x,in_.x);
    else if(channels == "wxy") return float3(in_.w,in_.x,in_.y);
    else if(channels == "wxz") return float3(in_.w,in_.x,in_.z);
    else if(channels == "wxw") return float3(in_.w,in_.x,in_.w);
    else if(channels == "wyx") return float3(in_.w,in_.y,in_.x);
    else if(channels == "wyy") return float3(in_.w,in_.y,in_.y);
    else if(channels == "wyz") return float3(in_.w,in_.y,in_.z);
    else if(channels == "wyw") return float3(in_.w,in_.y,in_.w);
    else if(channels == "wzx") return float3(in_.w,in_.z,in_.x);
    else if(channels == "wzy") return float3(in_.w,in_.z,in_.y);
    else if(channels == "wzz") return float3(in_.w,in_.z,in_.z);
    else if(channels == "wzw") return float3(in_.w,in_.z,in_.w);
    else if(channels == "wwx") return float3(in_.w,in_.w,in_.x);
    else if(channels == "wwy") return float3(in_.w,in_.w,in_.y);
    else if(channels == "wwz") return float3(in_.w,in_.w,in_.z);
    else if(channels == "www") return float3(in_.w,in_.w,in_.w);
    else return float3(0.0);
}
export float4 swizzle_vector4(
    varying float4 in_=float4(0.f,0.f,0.f,0.f),
    uniform string channels=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx swizzle"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    if     (channels == "xxxx") return float4(in_.x,in_.x,in_.x,in_.x);
    else if(channels == "xxxy") return float4(in_.x,in_.x,in_.x,in_.y);
    else if(channels == "xxxz") return float4(in_.x,in_.x,in_.x,in_.z);
    else if(channels == "xxxw") return float4(in_.x,in_.x,in_.x,in_.w);
    else if(channels == "xxyx") return float4(in_.x,in_.x,in_.y,in_.x);
    else if(channels == "xxyy") return float4(in_.x,in_.x,in_.y,in_.y);
    else if(channels == "xxyz") return float4(in_.x,in_.x,in_.y,in_.z);
    else if(channels == "xxyw") return float4(in_.x,in_.x,in_.y,in_.w);
    else if(channels == "xxzx") return float4(in_.x,in_.x,in_.z,in_.x);
    else if(channels == "xxzy") return float4(in_.x,in_.x,in_.z,in_.y);
    else if(channels == "xxzz") return float4(in_.x,in_.x,in_.z,in_.z);
    else if(channels == "xxzw") return float4(in_.x,in_.x,in_.z,in_.w);
    else if(channels == "xxwx") return float4(in_.x,in_.x,in_.w,in_.x);
    else if(channels == "xxwy") return float4(in_.x,in_.x,in_.w,in_.y);
    else if(channels == "xxwz") return float4(in_.x,in_.x,in_.w,in_.z);
    else if(channels == "xxww") return float4(in_.x,in_.x,in_.w,in_.w);
    else if(channels == "xyxx") return float4(in_.x,in_.y,in_.x,in_.x);
    else if(channels == "xyxy") return float4(in_.x,in_.y,in_.x,in_.y);
    else if(channels == "xyxz") return float4(in_.x,in_.y,in_.x,in_.z);
    else if(channels == "xyxw") return float4(in_.x,in_.y,in_.x,in_.w);
    else if(channels == "xyyx") return float4(in_.x,in_.y,in_.y,in_.x);
    else if(channels == "xyyy") return float4(in_.x,in_.y,in_.y,in_.y);
    else if(channels == "xyyz") return float4(in_.x,in_.y,in_.y,in_.z);
    else if(channels == "xyyw") return float4(in_.x,in_.y,in_.y,in_.w);
    else if(channels == "xyzx") return float4(in_.x,in_.y,in_.z,in_.x);
    else if(channels == "xyzy") return float4(in_.x,in_.y,in_.z,in_.y);
    else if(channels == "xyzz") return float4(in_.x,in_.y,in_.z,in_.z);
    else if(channels == "xyzw") return float4(in_.x,in_.y,in_.z,in_.w);
    else if(channels == "xywx") return float4(in_.x,in_.y,in_.w,in_.x);
    else if(channels == "xywy") return float4(in_.x,in_.y,in_.w,in_.y);
    else if(channels == "xywz") return float4(in_.x,in_.y,in_.w,in_.z);
    else if(channels == "xyww") return float4(in_.x,in_.y,in_.w,in_.w);
    else if(channels == "xzxx") return float4(in_.x,in_.z,in_.x,in_.x);
    else if(channels == "xzxy") return float4(in_.x,in_.z,in_.x,in_.y);
    else if(channels == "xzxz") return float4(in_.x,in_.z,in_.x,in_.z);
    else if(channels == "xzxw") return float4(in_.x,in_.z,in_.x,in_.w);
    else if(channels == "xzyx") return float4(in_.x,in_.z,in_.y,in_.x);
    else if(channels == "xzyy") return float4(in_.x,in_.z,in_.y,in_.y);
    else if(channels == "xzyz") return float4(in_.x,in_.z,in_.y,in_.z);
    else if(channels == "xzyw") return float4(in_.x,in_.z,in_.y,in_.w);
    else if(channels == "xzzx") return float4(in_.x,in_.z,in_.z,in_.x);
    else if(channels == "xzzy") return float4(in_.x,in_.z,in_.z,in_.y);
    else if(channels == "xzzz") return float4(in_.x,in_.z,in_.z,in_.z);
    else if(channels == "xzzw") return float4(in_.x,in_.z,in_.z,in_.w);
    else if(channels == "xzwx") return float4(in_.x,in_.z,in_.w,in_.x);
    else if(channels == "xzwy") return float4(in_.x,in_.z,in_.w,in_.y);
    else if(channels == "xzwz") return float4(in_.x,in_.z,in_.w,in_.z);
    else if(channels == "xzww") return float4(in_.x,in_.z,in_.w,in_.w);
    else if(channels == "xwxx") return float4(in_.x,in_.w,in_.x,in_.x);
    else if(channels == "xwxy") return float4(in_.x,in_.w,in_.x,in_.y);
    else if(channels == "xwxz") return float4(in_.x,in_.w,in_.x,in_.z);
    else if(channels == "xwxw") return float4(in_.x,in_.w,in_.x,in_.w);
    else if(channels == "xwyx") return float4(in_.x,in_.w,in_.y,in_.x);
    else if(channels == "xwyy") return float4(in_.x,in_.w,in_.y,in_.y);
    else if(channels == "xwyz") return float4(in_.x,in_.w,in_.y,in_.z);
    else if(channels == "xwyw") return float4(in_.x,in_.w,in_.y,in_.w);
    else if(channels == "xwzx") return float4(in_.x,in_.w,in_.z,in_.x);
    else if(channels == "xwzy") return float4(in_.x,in_.w,in_.z,in_.y);
    else if(channels == "xwzz") return float4(in_.x,in_.w,in_.z,in_.z);
    else if(channels == "xwzw") return float4(in_.x,in_.w,in_.z,in_.w);
    else if(channels == "xwwx") return float4(in_.x,in_.w,in_.w,in_.x);
    else if(channels == "xwwy") return float4(in_.x,in_.w,in_.w,in_.y);
    else if(channels == "xwwz") return float4(in_.x,in_.w,in_.w,in_.z);
    else if(channels == "xwww") return float4(in_.x,in_.w,in_.w,in_.w);
    else if(channels == "yxxx") return float4(in_.y,in_.x,in_.x,in_.x);
    else if(channels == "yxxy") return float4(in_.y,in_.x,in_.x,in_.y);
    else if(channels == "yxxz") return float4(in_.y,in_.x,in_.x,in_.z);
    else if(channels == "yxxw") return float4(in_.y,in_.x,in_.x,in_.w);
    else if(channels == "yxyx") return float4(in_.y,in_.x,in_.y,in_.x);
    else if(channels == "yxyy") return float4(in_.y,in_.x,in_.y,in_.y);
    else if(channels == "yxyz") return float4(in_.y,in_.x,in_.y,in_.z);
    else if(channels == "yxyw") return float4(in_.y,in_.x,in_.y,in_.w);
    else if(channels == "yxzx") return float4(in_.y,in_.x,in_.z,in_.x);
    else if(channels == "yxzy") return float4(in_.y,in_.x,in_.z,in_.y);
    else if(channels == "yxzz") return float4(in_.y,in_.x,in_.z,in_.z);
    else if(channels == "yxzw") return float4(in_.y,in_.x,in_.z,in_.w);
    else if(channels == "yxwx") return float4(in_.y,in_.x,in_.w,in_.x);
    else if(channels == "yxwy") return float4(in_.y,in_.x,in_.w,in_.y);
    else if(channels == "yxwz") return float4(in_.y,in_.x,in_.w,in_.z);
    else if(channels == "yxww") return float4(in_.y,in_.x,in_.w,in_.w);
    else if(channels == "yyxx") return float4(in_.y,in_.y,in_.x,in_.x);
    else if(channels == "yyxy") return float4(in_.y,in_.y,in_.x,in_.y);
    else if(channels == "yyxz") return float4(in_.y,in_.y,in_.x,in_.z);
    else if(channels == "yyxw") return float4(in_.y,in_.y,in_.x,in_.w);
    else if(channels == "yyyx") return float4(in_.y,in_.y,in_.y,in_.x);
    else if(channels == "yyyy") return float4(in_.y,in_.y,in_.y,in_.y);
    else if(channels == "yyyz") return float4(in_.y,in_.y,in_.y,in_.z);
    else if(channels == "yyyw") return float4(in_.y,in_.y,in_.y,in_.w);
    else if(channels == "yyzx") return float4(in_.y,in_.y,in_.z,in_.x);
    else if(channels == "yyzy") return float4(in_.y,in_.y,in_.z,in_.y);
    else if(channels == "yyzz") return float4(in_.y,in_.y,in_.z,in_.z);
    else if(channels == "yyzw") return float4(in_.y,in_.y,in_.z,in_.w);
    else if(channels == "yywx") return float4(in_.y,in_.y,in_.w,in_.x);
    else if(channels == "yywy") return float4(in_.y,in_.y,in_.w,in_.y);
    else if(channels == "yywz") return float4(in_.y,in_.y,in_.w,in_.z);
    else if(channels == "yyww") return float4(in_.y,in_.y,in_.w,in_.w);
    else if(channels == "yzxx") return float4(in_.y,in_.z,in_.x,in_.x);
    else if(channels == "yzxy") return float4(in_.y,in_.z,in_.x,in_.y);
    else if(channels == "yzxz") return float4(in_.y,in_.z,in_.x,in_.z);
    else if(channels == "yzxw") return float4(in_.y,in_.z,in_.x,in_.w);
    else if(channels == "yzyx") return float4(in_.y,in_.z,in_.y,in_.x);
    else if(channels == "yzyy") return float4(in_.y,in_.z,in_.y,in_.y);
    else if(channels == "yzyz") return float4(in_.y,in_.z,in_.y,in_.z);
    else if(channels == "yzyw") return float4(in_.y,in_.z,in_.y,in_.w);
    else if(channels == "yzzx") return float4(in_.y,in_.z,in_.z,in_.x);
    else if(channels == "yzzy") return float4(in_.y,in_.z,in_.z,in_.y);
    else if(channels == "yzzz") return float4(in_.y,in_.z,in_.z,in_.z);
    else if(channels == "yzzw") return float4(in_.y,in_.z,in_.z,in_.w);
    else if(channels == "yzwx") return float4(in_.y,in_.z,in_.w,in_.x);
    else if(channels == "yzwy") return float4(in_.y,in_.z,in_.w,in_.y);
    else if(channels == "yzwz") return float4(in_.y,in_.z,in_.w,in_.z);
    else if(channels == "yzww") return float4(in_.y,in_.z,in_.w,in_.w);
    else if(channels == "ywxx") return float4(in_.y,in_.w,in_.x,in_.x);
    else if(channels == "ywxy") return float4(in_.y,in_.w,in_.x,in_.y);
    else if(channels == "ywxz") return float4(in_.y,in_.w,in_.x,in_.z);
    else if(channels == "ywxw") return float4(in_.y,in_.w,in_.x,in_.w);
    else if(channels == "ywyx") return float4(in_.y,in_.w,in_.y,in_.x);
    else if(channels == "ywyy") return float4(in_.y,in_.w,in_.y,in_.y);
    else if(channels == "ywyz") return float4(in_.y,in_.w,in_.y,in_.z);
    else if(channels == "ywyw") return float4(in_.y,in_.w,in_.y,in_.w);
    else if(channels == "ywzx") return float4(in_.y,in_.w,in_.z,in_.x);
    else if(channels == "ywzy") return float4(in_.y,in_.w,in_.z,in_.y);
    else if(channels == "ywzz") return float4(in_.y,in_.w,in_.z,in_.z);
    else if(channels == "ywzw") return float4(in_.y,in_.w,in_.z,in_.w);
    else if(channels == "ywwx") return float4(in_.y,in_.w,in_.w,in_.x);
    else if(channels == "ywwy") return float4(in_.y,in_.w,in_.w,in_.y);
    else if(channels == "ywwz") return float4(in_.y,in_.w,in_.w,in_.z);
    else if(channels == "ywww") return float4(in_.y,in_.w,in_.w,in_.w);
    else if(channels == "zxxx") return float4(in_.z,in_.x,in_.x,in_.x);
    else if(channels == "zxxy") return float4(in_.z,in_.x,in_.x,in_.y);
    else if(channels == "zxxz") return float4(in_.z,in_.x,in_.x,in_.z);
    else if(channels == "zxxw") return float4(in_.z,in_.x,in_.x,in_.w);
    else if(channels == "zxyx") return float4(in_.z,in_.x,in_.y,in_.x);
    else if(channels == "zxyy") return float4(in_.z,in_.x,in_.y,in_.y);
    else if(channels == "zxyz") return float4(in_.z,in_.x,in_.y,in_.z);
    else if(channels == "zxyw") return float4(in_.z,in_.x,in_.y,in_.w);
    else if(channels == "zxzx") return float4(in_.z,in_.x,in_.z,in_.x);
    else if(channels == "zxzy") return float4(in_.z,in_.x,in_.z,in_.y);
    else if(channels == "zxzz") return float4(in_.z,in_.x,in_.z,in_.z);
    else if(channels == "zxzw") return float4(in_.z,in_.x,in_.z,in_.w);
    else if(channels == "zxwx") return float4(in_.z,in_.x,in_.w,in_.x);
    else if(channels == "zxwy") return float4(in_.z,in_.x,in_.w,in_.y);
    else if(channels == "zxwz") return float4(in_.z,in_.x,in_.w,in_.z);
    else if(channels == "zxww") return float4(in_.z,in_.x,in_.w,in_.w);
    else if(channels == "zyxx") return float4(in_.z,in_.y,in_.x,in_.x);
    else if(channels == "zyxy") return float4(in_.z,in_.y,in_.x,in_.y);
    else if(channels == "zyxz") return float4(in_.z,in_.y,in_.x,in_.z);
    else if(channels == "zyxw") return float4(in_.z,in_.y,in_.x,in_.w);
    else if(channels == "zyyx") return float4(in_.z,in_.y,in_.y,in_.x);
    else if(channels == "zyyy") return float4(in_.z,in_.y,in_.y,in_.y);
    else if(channels == "zyyz") return float4(in_.z,in_.y,in_.y,in_.z);
    else if(channels == "zyyw") return float4(in_.z,in_.y,in_.y,in_.w);
    else if(channels == "zyzx") return float4(in_.z,in_.y,in_.z,in_.x);
    else if(channels == "zyzy") return float4(in_.z,in_.y,in_.z,in_.y);
    else if(channels == "zyzz") return float4(in_.z,in_.y,in_.z,in_.z);
    else if(channels == "zyzw") return float4(in_.z,in_.y,in_.z,in_.w);
    else if(channels == "zywx") return float4(in_.z,in_.y,in_.w,in_.x);
    else if(channels == "zywy") return float4(in_.z,in_.y,in_.w,in_.y);
    else if(channels == "zywz") return float4(in_.z,in_.y,in_.w,in_.z);
    else if(channels == "zyww") return float4(in_.z,in_.y,in_.w,in_.w);
    else if(channels == "zzxx") return float4(in_.z,in_.z,in_.x,in_.x);
    else if(channels == "zzxy") return float4(in_.z,in_.z,in_.x,in_.y);
    else if(channels == "zzxz") return float4(in_.z,in_.z,in_.x,in_.z);
    else if(channels == "zzxw") return float4(in_.z,in_.z,in_.x,in_.w);
    else if(channels == "zzyx") return float4(in_.z,in_.z,in_.y,in_.x);
    else if(channels == "zzyy") return float4(in_.z,in_.z,in_.y,in_.y);
    else if(channels == "zzyz") return float4(in_.z,in_.z,in_.y,in_.z);
    else if(channels == "zzyw") return float4(in_.z,in_.z,in_.y,in_.w);
    else if(channels == "zzzx") return float4(in_.z,in_.z,in_.z,in_.x);
    else if(channels == "zzzy") return float4(in_.z,in_.z,in_.z,in_.y);
    else if(channels == "zzzz") return float4(in_.z,in_.z,in_.z,in_.z);
    else if(channels == "zzzw") return float4(in_.z,in_.z,in_.z,in_.w);
    else if(channels == "zzwx") return float4(in_.z,in_.z,in_.w,in_.x);
    else if(channels == "zzwy") return float4(in_.z,in_.z,in_.w,in_.y);
    else if(channels == "zzwz") return float4(in_.z,in_.z,in_.w,in_.z);
    else if(channels == "zzww") return float4(in_.z,in_.z,in_.w,in_.w);
    else if(channels == "zwxx") return float4(in_.z,in_.w,in_.x,in_.x);
    else if(channels == "zwxy") return float4(in_.z,in_.w,in_.x,in_.y);
    else if(channels == "zwxz") return float4(in_.z,in_.w,in_.x,in_.z);
    else if(channels == "zwxw") return float4(in_.z,in_.w,in_.x,in_.w);
    else if(channels == "zwyx") return float4(in_.z,in_.w,in_.y,in_.x);
    else if(channels == "zwyy") return float4(in_.z,in_.w,in_.y,in_.y);
    else if(channels == "zwyz") return float4(in_.z,in_.w,in_.y,in_.z);
    else if(channels == "zwyw") return float4(in_.z,in_.w,in_.y,in_.w);
    else if(channels == "zwzx") return float4(in_.z,in_.w,in_.z,in_.x);
    else if(channels == "zwzy") return float4(in_.z,in_.w,in_.z,in_.y);
    else if(channels == "zwzz") return float4(in_.z,in_.w,in_.z,in_.z);
    else if(channels == "zwzw") return float4(in_.z,in_.w,in_.z,in_.w);
    else if(channels == "zwwx") return float4(in_.z,in_.w,in_.w,in_.x);
    else if(channels == "zwwy") return float4(in_.z,in_.w,in_.w,in_.y);
    else if(channels == "zwwz") return float4(in_.z,in_.w,in_.w,in_.z);
    else if(channels == "zwww") return float4(in_.z,in_.w,in_.w,in_.w);
    else if(channels == "wxxx") return float4(in_.w,in_.x,in_.x,in_.x);
    else if(channels == "wxxy") return float4(in_.w,in_.x,in_.x,in_.y);
    else if(channels == "wxxz") return float4(in_.w,in_.x,in_.x,in_.z);
    else if(channels == "wxxw") return float4(in_.w,in_.x,in_.x,in_.w);
    else if(channels == "wxyx") return float4(in_.w,in_.x,in_.y,in_.x);
    else if(channels == "wxyy") return float4(in_.w,in_.x,in_.y,in_.y);
    else if(channels == "wxyz") return float4(in_.w,in_.x,in_.y,in_.z);
    else if(channels == "wxyw") return float4(in_.w,in_.x,in_.y,in_.w);
    else if(channels == "wxzx") return float4(in_.w,in_.x,in_.z,in_.x);
    else if(channels == "wxzy") return float4(in_.w,in_.x,in_.z,in_.y);
    else if(channels == "wxzz") return float4(in_.w,in_.x,in_.z,in_.z);
    else if(channels == "wxzw") return float4(in_.w,in_.x,in_.z,in_.w);
    else if(channels == "wxwx") return float4(in_.w,in_.x,in_.w,in_.x);
    else if(channels == "wxwy") return float4(in_.w,in_.x,in_.w,in_.y);
    else if(channels == "wxwz") return float4(in_.w,in_.x,in_.w,in_.z);
    else if(channels == "wxww") return float4(in_.w,in_.x,in_.w,in_.w);
    else if(channels == "wyxx") return float4(in_.w,in_.y,in_.x,in_.x);
    else if(channels == "wyxy") return float4(in_.w,in_.y,in_.x,in_.y);
    else if(channels == "wyxz") return float4(in_.w,in_.y,in_.x,in_.z);
    else if(channels == "wyxw") return float4(in_.w,in_.y,in_.x,in_.w);
    else if(channels == "wyyx") return float4(in_.w,in_.y,in_.y,in_.x);
    else if(channels == "wyyy") return float4(in_.w,in_.y,in_.y,in_.y);
    else if(channels == "wyyz") return float4(in_.w,in_.y,in_.y,in_.z);
    else if(channels == "wyyw") return float4(in_.w,in_.y,in_.y,in_.w);
    else if(channels == "wyzx") return float4(in_.w,in_.y,in_.z,in_.x);
    else if(channels == "wyzy") return float4(in_.w,in_.y,in_.z,in_.y);
    else if(channels == "wyzz") return float4(in_.w,in_.y,in_.z,in_.z);
    else if(channels == "wyzw") return float4(in_.w,in_.y,in_.z,in_.w);
    else if(channels == "wywx") return float4(in_.w,in_.y,in_.w,in_.x);
    else if(channels == "wywy") return float4(in_.w,in_.y,in_.w,in_.y);
    else if(channels == "wywz") return float4(in_.w,in_.y,in_.w,in_.z);
    else if(channels == "wyww") return float4(in_.w,in_.y,in_.w,in_.w);
    else if(channels == "wzxx") return float4(in_.w,in_.z,in_.x,in_.x);
    else if(channels == "wzxy") return float4(in_.w,in_.z,in_.x,in_.y);
    else if(channels == "wzxz") return float4(in_.w,in_.z,in_.x,in_.z);
    else if(channels == "wzxw") return float4(in_.w,in_.z,in_.x,in_.w);
    else if(channels == "wzyx") return float4(in_.w,in_.z,in_.y,in_.x);
    else if(channels == "wzyy") return float4(in_.w,in_.z,in_.y,in_.y);
    else if(channels == "wzyz") return float4(in_.w,in_.z,in_.y,in_.z);
    else if(channels == "wzyw") return float4(in_.w,in_.z,in_.y,in_.w);
    else if(channels == "wzzx") return float4(in_.w,in_.z,in_.z,in_.x);
    else if(channels == "wzzy") return float4(in_.w,in_.z,in_.z,in_.y);
    else if(channels == "wzzz") return float4(in_.w,in_.z,in_.z,in_.z);
    else if(channels == "wzzw") return float4(in_.w,in_.z,in_.z,in_.w);
    else if(channels == "wzwx") return float4(in_.w,in_.z,in_.w,in_.x);
    else if(channels == "wzwy") return float4(in_.w,in_.z,in_.w,in_.y);
    else if(channels == "wzwz") return float4(in_.w,in_.z,in_.w,in_.z);
    else if(channels == "wzww") return float4(in_.w,in_.z,in_.w,in_.w);
    else if(channels == "wwxx") return float4(in_.w,in_.w,in_.x,in_.x);
    else if(channels == "wwxy") return float4(in_.w,in_.w,in_.x,in_.y);
    else if(channels == "wwxz") return float4(in_.w,in_.w,in_.x,in_.z);
    else if(channels == "wwxw") return float4(in_.w,in_.w,in_.x,in_.w);
    else if(channels == "wwyx") return float4(in_.w,in_.w,in_.y,in_.x);
    else if(channels == "wwyy") return float4(in_.w,in_.w,in_.y,in_.y);
    else if(channels == "wwyz") return float4(in_.w,in_.w,in_.y,in_.z);
    else if(channels == "wwyw") return float4(in_.w,in_.w,in_.y,in_.w);
    else if(channels == "wwzx") return float4(in_.w,in_.w,in_.z,in_.x);
    else if(channels == "wwzy") return float4(in_.w,in_.w,in_.z,in_.y);
    else if(channels == "wwzz") return float4(in_.w,in_.w,in_.z,in_.z);
    else if(channels == "wwzw") return float4(in_.w,in_.w,in_.z,in_.w);
    else if(channels == "wwwx") return float4(in_.w,in_.w,in_.w,in_.x);
    else if(channels == "wwwy") return float4(in_.w,in_.w,in_.w,in_.y);
    else if(channels == "wwwz") return float4(in_.w,in_.w,in_.w,in_.z);
    else if(channels == "wwww") return float4(in_.w,in_.w,in_.w,in_.w);
    else return float4(0.0);
}
// Error: Implementation for color2 combine missing
/*export color2 combine_color2(
    varying float in1=float(0.f),
    varying float in2=float(0.f)){ return color2(0.f, 0.f); }
*/
export float2 combine_vector2(
    varying float in1=float(0.f),
    varying float in2=float(0.f))
[[
    anno::display_name("Matx combine"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return float2(in1, in2);
}
export color3 combine_color3(
    varying float in1=float(0.f),
    varying float in2=float(0.f),
    varying float in3=float(0.f))
[[
    anno::display_name("Matx combine"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return color3(in1, in2, in3);
}
export float3 combine_vector3(
    varying float in1=float(0.f),
    varying float in2=float(0.f),
    varying float in3=float(0.f))
[[
    anno::display_name("Matx combine"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return float3(in1, in2, in3);
}
// Error: Implementation for color4 combine missing
/*export color4 combine_color4(
    varying float in1=float(0.f),
    varying float in2=float(0.f),
    varying float in3=float(0.f),
    varying float in4=float(0.f)){ return color4(0.f, 0.f, 0.f, 0.f); }
*/
export float4 combine_vector4(
    varying float in1=float(0.f),
    varying float in2=float(0.f),
    varying float in3=float(0.f),
    varying float in4=float(0.f))
[[
    anno::display_name("Matx combine"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return float4(in1, in2, in3, in4);
}
// Error: Implementation for color4 combine missing
/*export color4 combine(
    varying color3 in1=color3(0.f, 0.f, 0.f),
    varying float in2=float(0.f)){ return color4(0.f, 0.f, 0.f, 0.f); }
*/
export float4 combine(
    varying float3 in1=float3(0.f,0.f,0.f),
    varying float in2=float(0.f))
[[
    anno::display_name("Matx combine"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return float4(in1.x, in1.y, in1.z, in2);
}
// Unsupported MaterialX nodedef ND_combine_color4CC skipped
export float4 combine(
    varying float2 in1=float2(0.f,0.f),
    varying float2 in2=float2(0.f,0.f))
[[
    anno::display_name("Matx combine"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    return float4(in1.x, in1.y, in2.x, in2.y);
}
// Unsupported MaterialX nodedef ND_extract_color2 skipped
export float extract(
    varying color3 in_=color3(0.f, 0.f, 0.f),
    uniform int index=int(0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx extract"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    float v_0 = swizzle_float(in_, string("r"));
    float v_1 = swizzle_float(in_, string("g"));
    float v_2 = swizzle_float(in_, string("b"));
    float v_3 = switch_(v_0, v_1, v_2, index);
    return v_3;
}
// Unsupported MaterialX nodedef ND_extract_color4 skipped
export float extract(
    varying float2 in_=float2(0.f,0.f),
    uniform int index=int(0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx extract"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    float v_0 = swizzle_float(in_, string("x"));
    float v_1 = swizzle_float(in_, string("y"));
    float v_2 = switch_(v_0, v_1, index);
    return v_2;
}
export float extract(
    varying float3 in_=float3(0.f,0.f,0.f),
    uniform int index=int(0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx extract"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    float v_0 = swizzle_float(in_, string("x"));
    float v_1 = swizzle_float(in_, string("y"));
    float v_2 = swizzle_float(in_, string("z"));
    float v_3 = switch_(v_0, v_1, v_2, index);
    return v_3;
}
export float extract(
    varying float4 in_=float4(0.f,0.f,0.f,0.f),
    uniform int index=int(0)[[
        alg::base::annotations::visible_by_default(false)
    ]])
[[
    anno::display_name("Matx extract"),
    anno::description("MaterialX compliant node"),
    anno::author("Allegorithmic")
]]
{
    float v_0 = swizzle_float(in_, string("x"));
    float v_1 = swizzle_float(in_, string("y"));
    float v_2 = swizzle_float(in_, string("z"));
    float v_3 = swizzle_float(in_, string("w"));
    float v_4 = switch_(v_0, v_1, v_2, v_3, index);
    return v_4;
}
// Unsupported MaterialX nodedef ND_separate_color2 skipped
// Unsupported MaterialX nodedef ND_separate_color3 skipped
// Unsupported MaterialX nodedef ND_separate_color4 skipped
// Unsupported MaterialX nodedef ND_separate_vector2 skipped
// Unsupported MaterialX nodedef ND_separate_vector3 skipped
// Unsupported MaterialX nodedef ND_separate_vector4 skipped
// Error: Implementation for float blur missing
/*export float blur(
    varying float in_=float(0.f),
    uniform float size=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string filtertype=string("box")[[
        alg::base::annotations::visible_by_default(false)
    ]]){ return float(0.f); }
*/
// Unsupported MaterialX nodedef ND_blur_color2 skipped
// Error: Implementation for color3 blur missing
/*export color3 blur(
    varying color3 in_=color3(0.f, 0.f, 0.f),
    uniform float size=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string filtertype=string("box")[[
        alg::base::annotations::visible_by_default(false)
    ]]){ return color3(0.f, 0.f, 0.f); }
*/
// Unsupported MaterialX nodedef ND_blur_color4 skipped
// Error: Implementation for float2 blur missing
/*export float2 blur(
    varying float2 in_=float2(0.f,0.f),
    uniform float size=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string filtertype=string("box")[[
        alg::base::annotations::visible_by_default(false)
    ]]){ return float2(0.f,0.f); }
*/
// Error: Implementation for float3 blur missing
/*export float3 blur(
    varying float3 in_=float3(0.f,0.f,0.f),
    uniform float size=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string filtertype=string("box")[[
        alg::base::annotations::visible_by_default(false)
    ]]){ return float3(0.f,0.f,0.f); }
*/
// Error: Implementation for float4 blur missing
/*export float4 blur(
    varying float4 in_=float4(0.f,0.f,0.f,0.f),
    uniform float size=float(0.0)[[
        alg::base::annotations::visible_by_default(false)
    ]],
    uniform string filtertype=string("box")[[
        alg::base::annotations::visible_by_default(false)
    ]]){ return float4(0.f,0.f,0.f,0.f); }
*/
// Error: Implementation for float3 heighttonormal missing
/*export float3 heighttonormal(
    varying float in_=float(0.f),
    uniform float scale=float(1.0)[[
        alg::base::annotations::visible_by_default(false)
    ]]){ return float3(0.f,0.f,0.f); }
*/
// Error: Implementation for float dot missing
/*export float dot(
    varying float in_=float(0.f),
    uniform string note=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]]){ return float(0.f); }
*/
// Unsupported MaterialX nodedef ND_dot_color2 skipped
// Error: Implementation for color3 dot missing
/*export color3 dot(
    varying color3 in_=color3(0.f, 0.f, 0.f),
    uniform string note=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]]){ return color3(0.f, 0.f, 0.f); }
*/
// Unsupported MaterialX nodedef ND_dot_color4 skipped
// Error: Implementation for float2 dot missing
/*export float2 dot(
    varying float2 in_=float2(0.f,0.f),
    uniform string note=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]]){ return float2(0.f,0.f); }
*/
// Error: Implementation for float3 dot missing
/*export float3 dot(
    varying float3 in_=float3(0.f,0.f,0.f),
    uniform string note=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]]){ return float3(0.f,0.f,0.f); }
*/
// Error: Implementation for float4 dot missing
/*export float4 dot(
    varying float4 in_=float4(0.f,0.f,0.f,0.f),
    uniform string note=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]]){ return float4(0.f,0.f,0.f,0.f); }
*/
// Error: Implementation for bool dot missing
/*export bool dot(
    varying bool in_=bool(false),
    uniform string note=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]]){ return bool(false); }
*/
// Error: Implementation for int dot missing
/*export int dot(
    varying int in_=int(0),
    uniform string note=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]]){ return int(0); }
*/
// Error: Implementation for float3x3 dot missing
/*export float3x3 dot(
    varying float3x3 in_=float3x3(0.f),
    uniform string note=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]]){ return float3x3(0.f); }
*/
// Error: Implementation for float4x4 dot missing
/*export float4x4 dot(
    varying float4x4 in_=float4x4(0.f),
    uniform string note=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]]){ return float4x4(0.f); }
*/
// Error: Implementation for string dot missing
/*export string dot(
    varying string in_=string(""),
    uniform string note=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]]){ return string(""); }
*/
// skipping dot, cannot return texture_* types

// Error: material type nodes are dummy implemented
/*export material dot(
    varying material in_=material(),
    uniform string note=string("")[[
        alg::base::annotations::visible_by_default(false)
    ]])=mtlx::utilities::dummyMaterial();
*/
// Unsupported MaterialX nodedef ND_dot_displacementshader skipped
// Unsupported MaterialX nodedef ND_dot_volumeshader skipped
// Unsupported MaterialX nodedef ND_dot_lightshader skipped
// Unsupported MaterialX nodedef ND_backdrop_float skipped
